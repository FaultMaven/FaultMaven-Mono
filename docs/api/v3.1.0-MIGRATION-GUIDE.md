# FaultMaven v3.1.0 Migration Guide

## Overview

This guide helps developers migrate from the legacy FaultMaven API format to the new v3.1.0 schema. The migration preserves all existing functionality while adding new capabilities for intent-driven responses, evidence attribution, and structured state management.

## Migration Timeline & Strategy

### Phase 1: Understanding the Changes (Immediate)
- Review this migration guide
- Understand the new schema concepts
- Plan your migration approach

### Phase 2: Parallel Implementation (Week 1-2)  
- Implement v3.1.0 handlers alongside legacy code
- Test new endpoints with existing workflows
- Update error handling for new error format

### Phase 3: Gradual Rollout (Week 3-4)
- Switch non-critical features to v3.1.0
- Monitor performance and user experience
- Address any integration issues

### Phase 4: Full Migration (Week 5-6)
- Migrate all features to v3.1.0 schema
- Remove legacy code and dependencies
- Update documentation and training materials

## Key Changes Summary

| Aspect | Legacy Format | v3.1.0 Schema | Impact |
|--------|---------------|---------------|--------|
| **Response Structure** | Flat findings/recommendations | Structured content + metadata | üîÑ Medium - Requires response parsing changes |
| **Error Format** | HTTP status + message | Structured error object | üîÑ Medium - Update error handling |
| **Evidence** | No source attribution | Structured sources array | üÜï New - Optional enhancement |
| **Intent** | Inferred from content | Explicit response_type | üîÑ Medium - Enables better UI decisions |
| **State Management** | External state tracking | Built-in ViewState | üÜï New - Simplifies frontend logic |
| **Multi-step Plans** | Text recommendations | Structured plan steps | üÜï New - Better UX for complex solutions |

## Step-by-Step Migration

### Step 1: Update API Endpoints

**Legacy Endpoint**:
```
POST /api/v1/agent/troubleshoot
```

**New Endpoint**:
```  
POST /api/v1/agent/query
```

**Request Format** (unchanged):
```json
{
  "session_id": "sess_abc123",
  "query": "Why am I getting HTTP 500 errors?"
}
```

### Step 2: Update Response Models

#### Legacy Response Model

```typescript
// ‚ùå Legacy - Remove this
interface LegacyTroubleshootingResponse {
  investigation_id: string;
  status: string;
  findings: Finding[];
  recommendations: Recommendation[];
  session_id: string;
  reasoning_trace: ReasoningStep[];
  root_cause?: string;
  confidence_score?: number;
  estimated_mttr?: string;
  next_steps?: string[];
  created_at: string;
  completed_at?: string;
}

interface Finding {
  type: string;
  message: string;
  severity: string;
  confidence: number;
  evidence: string[];
  timestamp: string;
  source: string;
}

interface Recommendation {
  action: string;
  priority: string;
  impact: string;
  effort: string;
  category?: string;
  estimated_time?: string;
}
```

#### New v3.1.0 Models

```typescript
// ‚úÖ New - Add these models
interface AgentResponse {
  schema_version: "3.1.0";
  content: string;
  response_type: ResponseType;
  view_state: ViewState;
  sources?: Source[];
  plan?: PlanStep[];
}

enum ResponseType {
  ANSWER = "answer",
  PLAN_PROPOSAL = "plan_proposal", 
  CLARIFICATION_REQUEST = "clarification_request",
  CONFIRMATION_REQUEST = "confirmation_request"
}

interface ViewState {
  session_id: string;
  case_id: string;
  running_summary: string;
  uploaded_data: UploadedData[];
}

interface Source {
  type: SourceType;
  name: string;
  snippet: string;
}

enum SourceType {
  KNOWLEDGE_BASE = "knowledge_base",
  LOG_FILE = "log_file",
  WEB_SEARCH = "web_search"
}

interface PlanStep {
  description: string;
}

interface UploadedData {
  id: string;
  name: string;
  type: string;
}

// Error handling
interface ErrorResponse {
  schema_version: "3.1.0";
  error: {
    code: string;
    message: string;
  };
}
```

### Step 3: Update Response Processing

#### Legacy Response Handling

```typescript
// ‚ùå Legacy - Replace this
function handleLegacyResponse(response: LegacyTroubleshootingResponse) {
  // Display findings
  response.findings.forEach(finding => {
    displayFinding(finding.message, finding.severity, finding.evidence);
  });
  
  // Display recommendations  
  response.recommendations.forEach(rec => {
    displayRecommendation(rec.action, rec.priority, rec.impact);
  });
  
  // Show investigation ID
  setInvestigationId(response.investigation_id);
  
  // Display root cause if available
  if (response.root_cause) {
    displayRootCause(response.root_cause);
  }
  
  // Show confidence and MTTR
  displayMetrics(response.confidence_score, response.estimated_mttr);
}
```

#### New v3.1.0 Response Handling

```typescript
// ‚úÖ New - Use this approach
function handleAgentResponse(response: AgentResponse) {
  // Update view state first
  updateViewState(response.view_state);
  
  // Handle based on response type
  switch (response.response_type) {
    case ResponseType.ANSWER:
      displayAnswer(response.content, response.sources);
      break;
      
    case ResponseType.PLAN_PROPOSAL:
      displayPlan(response.content, response.plan, response.sources);
      break;
      
    case ResponseType.CLARIFICATION_REQUEST:
      showClarificationPrompt(response.content, response.sources);
      break;
      
    case ResponseType.CONFIRMATION_REQUEST:
      showConfirmationDialog(response.content, response.sources);
      break;
      
    default:
      console.error('Unknown response type:', response.response_type);
  }
}

function displayAnswer(content: string, sources: Source[] = []) {
  // Display main content
  const contentElement = createContentElement(content);
  
  // Add source attribution for trust
  if (sources.length > 0) {
    const sourcesElement = createSourcesElement(sources);
    contentElement.appendChild(sourcesElement);
  }
  
  addToChat(contentElement);
}

function displayPlan(content: string, plan: PlanStep[] = [], sources: Source[] = []) {
  // Display plan introduction
  const introElement = createContentElement(content);
  
  // Display structured plan steps
  const planElement = document.createElement('div');
  planElement.className = 'troubleshooting-plan';
  
  plan.forEach((step, index) => {
    const stepElement = document.createElement('div');
    stepElement.className = 'plan-step';
    stepElement.innerHTML = `
      <div class="step-number">${index + 1}</div>
      <div class="step-description">${step.description}</div>
      <div class="step-actions">
        <button onclick="markStepComplete(${index})">Mark Complete</button>
      </div>
    `;
    planElement.appendChild(stepElement);
  });
  
  // Add sources
  if (sources.length > 0) {
    planElement.appendChild(createSourcesElement(sources));
  }
  
  const containerElement = document.createElement('div');
  containerElement.appendChild(introElement);
  containerElement.appendChild(planElement);
  
  addToChat(containerElement);
}

function updateViewState(viewState: ViewState) {
  // Update case tracking
  document.getElementById('current-case').textContent = viewState.case_id;
  document.getElementById('investigation-summary').textContent = viewState.running_summary;
  
  // Update uploaded data list
  const dataList = document.getElementById('uploaded-data-list');
  dataList.innerHTML = '';
  viewState.uploaded_data.forEach(data => {
    const item = document.createElement('li');
    item.innerHTML = `
      <span class="data-name">${data.name}</span>
      <span class="data-type">${data.type}</span>
    `;
    dataList.appendChild(item);
  });
  
  // Store for session persistence
  sessionStorage.setItem('faultmaven_view_state', JSON.stringify(viewState));
}

function createSourcesElement(sources: Source[]): HTMLElement {
  const sourcesContainer = document.createElement('div');
  sourcesContainer.className = 'evidence-sources';
  
  const header = document.createElement('h4');
  header.textContent = 'Evidence Sources:';
  sourcesContainer.appendChild(header);
  
  const sourcesList = document.createElement('ul');
  sources.forEach(source => {
    const sourceItem = document.createElement('li');
    sourceItem.className = `source-${source.type}`;
    sourceItem.innerHTML = `
      <div class="source-header">
        <span class="source-type">${source.type.replace('_', ' ')}</span>
        <span class="source-name">${source.name}</span>
      </div>
      <div class="source-snippet">"${source.snippet}"</div>
    `;
    sourcesList.appendChild(sourceItem);
  });
  
  sourcesContainer.appendChild(sourcesList);
  return sourcesContainer;
}
```

### Step 4: Update Error Handling

#### Legacy Error Handling

```typescript
// ‚ùå Legacy - Replace this
async function callLegacyAPI(sessionId: string, query: string) {
  try {
    const response = await fetch('/api/v1/agent/troubleshoot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, query })
    });
    
    if (!response.ok) {
      // Legacy error handling
      if (response.status === 404) {
        throw new Error('Session not found');
      } else if (response.status === 500) {
        throw new Error('Server error occurred');
      } else {
        const errorText = await response.text();
        throw new Error(errorText || 'Unknown error');
      }
    }
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}
```

#### New v3.1.0 Error Handling

```typescript
// ‚úÖ New - Use structured error handling
async function callV3API(sessionId: string, query: string): Promise<AgentResponse> {
  try {
    const response = await fetch('/api/v1/agent/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, query })
    });
    
    if (!response.ok) {
      const errorData: ErrorResponse = await response.json();
      
      // Handle specific error codes
      switch (errorData.error.code) {
        case 'SESSION_NOT_FOUND':
          // Automatically create new session
          const newSessionId = await createNewSession();
          return await callV3API(newSessionId, query);
          
        case 'RATE_LIMIT_EXCEEDED':
          // Implement backoff strategy
          await delay(5000);
          return await callV3API(sessionId, query);
          
        case 'QUERY_TOO_LONG':
          throw new ValidationError('Query is too long. Please shorten your request.');
          
        case 'SERVICE_UNAVAILABLE':
          throw new ServiceError('FaultMaven service is temporarily unavailable. Please try again later.');
          
        default:
          throw new APIError(`API Error: ${errorData.error.message}`, errorData.error.code);
      }
    }
    
    const agentResponse: AgentResponse = await response.json();
    
    // Validate response structure
    if (!isValidAgentResponse(agentResponse)) {
      throw new ValidationError('Invalid response format received from API');
    }
    
    return agentResponse;
    
  } catch (error) {
    if (error instanceof ValidationError || error instanceof ServiceError) {
      throw error; // Re-throw custom errors
    }
    
    console.error('API call failed:', error);
    throw new APIError('Failed to communicate with FaultMaven API', 'NETWORK_ERROR');
  }
}

// Custom error classes for better error handling
class APIError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'APIError';
  }
}

class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

class ServiceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ServiceError';
  }
}

function isValidAgentResponse(response: any): response is AgentResponse {
  return (
    response &&
    response.schema_version === "3.1.0" &&
    typeof response.content === 'string' &&
    ['answer', 'plan_proposal', 'clarification_request', 'confirmation_request'].includes(response.response_type) &&
    response.view_state &&
    typeof response.view_state.session_id === 'string' &&
    typeof response.view_state.case_id === 'string'
  );
}
```

### Step 5: Implement Migration Adapter

For gradual migration, use an adapter pattern:

```typescript
// Migration adapter to support both formats during transition
class FaultMavenAdapter {
  private useV3Schema: boolean;
  
  constructor(useV3Schema = false) {
    this.useV3Schema = useV3Schema;
  }
  
  async query(sessionId: string, query: string) {
    if (this.useV3Schema) {
      return await this.queryV3(sessionId, query);
    } else {
      return await this.queryLegacy(sessionId, query);
    }
  }
  
  private async queryV3(sessionId: string, query: string): Promise<AgentResponse> {
    return await callV3API(sessionId, query);
  }
  
  private async queryLegacy(sessionId: string, query: string): Promise<LegacyTroubleshootingResponse> {
    const response = await fetch('/api/v1/agent/troubleshoot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, query })
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    
    return await response.json();
  }
  
  // Enable v3.1.0 schema for this instance
  enableV3Schema() {
    this.useV3Schema = true;
  }
  
  // Disable v3.1.0 schema (fallback to legacy)
  disablev3Schema() {
    this.useV3Schema = false;
  }
}

// Usage example with feature flags
const adapter = new FaultMavenAdapter(
  featureFlags.isEnabled('v3_schema') // Enable v3.1.0 based on feature flag
);
```

## Data Mapping Guide

### Converting Legacy Findings to v3.1.0

Legacy findings can be mapped to the new format:

```typescript
// Conversion utility for legacy data
function convertLegacyToV3(legacyResponse: LegacyTroubleshootingResponse): AgentResponse {
  // Determine response type based on legacy data
  let responseType: ResponseType = ResponseType.ANSWER;
  let plan: PlanStep[] | undefined;
  
  if (legacyResponse.next_steps && legacyResponse.next_steps.length > 0) {
    responseType = ResponseType.PLAN_PROPOSAL;
    plan = legacyResponse.next_steps.map(step => ({ description: step }));
  }
  
  // Build content from legacy findings and recommendations
  let content = '';
  if (legacyResponse.root_cause) {
    content += `Root Cause: ${legacyResponse.root_cause}\n\n`;
  }
  
  if (legacyResponse.findings.length > 0) {
    content += 'Key Findings:\n';
    legacyResponse.findings.forEach(finding => {
      content += `‚Ä¢ ${finding.message}\n`;
    });
    content += '\n';
  }
  
  if (legacyResponse.recommendations.length > 0) {
    content += 'Recommendations:\n';
    legacyResponse.recommendations.forEach(rec => {
      content += `‚Ä¢ ${rec.action}\n`;
    });
  }
  
  // Convert findings to sources
  const sources: Source[] = legacyResponse.findings
    .filter(finding => finding.evidence.length > 0)
    .map(finding => ({
      type: SourceType.LOG_FILE, // Default type for legacy data
      name: finding.source || 'Legacy Data',
      snippet: finding.evidence[0] || finding.message
    }));
  
  // Create view state
  const viewState: ViewState = {
    session_id: legacyResponse.session_id,
    case_id: legacyResponse.investigation_id,
    running_summary: content.substring(0, 200) + '...', // Truncated summary
    uploaded_data: [] // No uploaded data in legacy format
  };
  
  return {
    schema_version: "3.1.0",
    content: content.trim(),
    response_type: responseType,
    view_state: viewState,
    sources: sources,
    plan: plan
  };
}
```

## Testing Migration

### Unit Tests for Migration

```typescript
describe('v3.1.0 Migration', () => {
  test('converts legacy response to v3.1.0 format', () => {
    const legacyResponse: LegacyTroubleshootingResponse = {
      investigation_id: 'inv_123',
      session_id: 'sess_456',
      status: 'completed',
      findings: [{
        type: 'root_cause',
        message: 'Database connection pool exhausted',
        severity: 'high',
        confidence: 0.9,
        evidence: ['Pool size: 20, Active: 20'],
        timestamp: '2025-01-15T10:30:00Z',
        source: 'application.log'
      }],
      recommendations: [{
        action: 'Increase connection pool size',
        priority: 'immediate',
        impact: 'Restores service',
        effort: 'low'
      }],
      reasoning_trace: [],
      root_cause: 'Connection pool exhaustion',
      created_at: '2025-01-15T10:30:00Z'
    };
    
    const converted = convertLegacyToV3(legacyResponse);
    
    expect(converted.schema_version).toBe('3.1.0');
    expect(converted.response_type).toBe('answer');
    expect(converted.view_state.case_id).toBe('inv_123');
    expect(converted.sources).toHaveLength(1);
    expect(converted.sources[0].snippet).toBe('Pool size: 20, Active: 20');
  });
  
  test('handles legacy response with next_steps as plan', () => {
    const legacyWithSteps: LegacyTroubleshootingResponse = {
      // ... other fields
      next_steps: [
        'Increase pool size',
        'Monitor for 10 minutes', 
        'Review connection leaks'
      ]
    };
    
    const converted = convertLegacyToV3(legacyWithSteps);
    
    expect(converted.response_type).toBe('plan_proposal');
    expect(converted.plan).toHaveLength(3);
    expect(converted.plan[0].description).toBe('Increase pool size');
  });
});
```

### Integration Tests

```typescript
describe('API Migration Integration', () => {
  test('adapter works with both endpoints', async () => {
    const adapter = new FaultMavenAdapter(false); // Start with legacy
    
    // Test legacy endpoint
    const legacyResult = await adapter.query('sess_123', 'Test query');
    expect(legacyResult).toHaveProperty('investigation_id');
    
    // Switch to v3.1.0
    adapter.enableV3Schema();
    
    // Test v3.1.0 endpoint
    const v3Result = await adapter.query('sess_123', 'Test query');
    expect(v3Result).toHaveProperty('schema_version', '3.1.0');
    expect(v3Result).toHaveProperty('response_type');
  });
  
  test('error handling works consistently', async () => {
    const adapter = new FaultMavenAdapter(true);
    
    // Test invalid session
    await expect(adapter.query('invalid_session', 'Test'))
      .rejects.toThrow('SESSION_NOT_FOUND');
  });
});
```

## Common Migration Issues

### Issue 1: Missing Plan Validation

**Problem**: Frontend crashes when `plan` field is present for non-`plan_proposal` responses.

**Solution**: Always validate response structure:

```typescript
// ‚úÖ Correct - Validate before processing
function validateAndProcess(response: AgentResponse) {
  // Validate plan consistency  
  if (response.response_type === 'plan_proposal') {
    if (!response.plan || response.plan.length === 0) {
      throw new ValidationError('PLAN_PROPOSAL response must include plan');
    }
  } else {
    if (response.plan) {
      throw new ValidationError(`Plan field not allowed for ${response.response_type}`);
    }
  }
  
  return handleAgentResponse(response);
}
```

### Issue 2: Ignoring ViewState Updates

**Problem**: Frontend becomes out of sync with backend state.

**Solution**: Always update ViewState:

```typescript
// ‚úÖ Correct - Always process ViewState
function processResponse(response: AgentResponse) {
  // Update view state FIRST
  updateViewState(response.view_state);
  
  // Then process response content
  handleResponseContent(response);
}
```

### Issue 3: Not Handling All Response Types

**Problem**: Application breaks when receiving unexpected response types.

**Solution**: Implement comprehensive response type handling:

```typescript
// ‚úÖ Correct - Handle all response types
function handleResponseType(response: AgentResponse) {
  switch (response.response_type) {
    case 'answer':
      return displayAnswer(response);
    case 'plan_proposal':
      return displayPlan(response);
    case 'clarification_request':
      return showClarificationForm(response);
    case 'confirmation_request':
      return showConfirmationDialog(response);
    default:
      console.warn('Unknown response type:', response.response_type);
      // Fallback to answer display
      return displayAnswer(response);
  }
}
```

### Issue 4: Legacy Error Format Expectations

**Problem**: Error handling expects old HTTP status-based errors.

**Solution**: Update error handling for structured errors:

```typescript
// ‚ùå Wrong - Legacy error handling
.catch(error => {
  if (error.status === 404) {
    // This won't work with v3.1.0
  }
});

// ‚úÖ Correct - v3.1.0 error handling  
.catch(error => {
  if (error instanceof APIError && error.code === 'SESSION_NOT_FOUND') {
    // Handle structured error
  }
});
```

## Rollback Strategy

If issues arise during migration, implement this rollback strategy:

```typescript
// Emergency rollback configuration
class MigrationManager {
  private rollbackConfig = {
    useV3Schema: true,
    rollbackThreshold: 0.95, // Roll back if success rate < 95%
    successCount: 0,
    totalCount: 0
  };
  
  async query(sessionId: string, query: string) {
    this.rollbackConfig.totalCount++;
    
    try {
      if (this.rollbackConfig.useV3Schema) {
        const result = await callV3API(sessionId, query);
        this.rollbackConfig.successCount++;
        return result;
      } else {
        return await callLegacyAPI(sessionId, query);
      }
    } catch (error) {
      // Check if we should rollback
      const successRate = this.rollbackConfig.successCount / this.rollbackConfig.totalCount;
      if (successRate < this.rollbackConfig.rollbackThreshold) {
        console.warn('Rolling back to legacy API due to low success rate:', successRate);
        this.rollbackConfig.useV3Schema = false;
        
        // Retry with legacy API
        return await callLegacyAPI(sessionId, query);
      }
      
      throw error;
    }
  }
}
```

## Performance Considerations

### Response Size Impact

v3.1.0 responses include more metadata. Monitor response sizes:

```typescript
// Monitor response sizes during migration
function monitorResponseSize(response: AgentResponse) {
  const responseSize = JSON.stringify(response).length;
  const sourcesSize = JSON.stringify(response.sources || []).length;
  const viewStateSize = JSON.stringify(response.view_state).length;
  
  // Log metrics for monitoring
  console.log('Response metrics:', {
    totalSize: responseSize,
    sourcesSize: sourcesSize,
    viewStateSize: viewStateSize,
    sourcesCount: response.sources?.length || 0
  });
  
  // Alert if response is unusually large
  if (responseSize > 50000) { // 50KB threshold
    console.warn('Large response detected:', responseSize, 'bytes');
  }
}
```

### Caching Strategy

Implement caching for ViewState to reduce API calls:

```typescript
class ViewStateCache {
  private cache = new Map<string, { state: ViewState; timestamp: number }>();
  private maxAge = 5 * 60 * 1000; // 5 minutes
  
  get(sessionId: string): ViewState | null {
    const cached = this.cache.get(sessionId);
    if (cached && (Date.now() - cached.timestamp) < this.maxAge) {
      return cached.state;
    }
    return null;
  }
  
  set(viewState: ViewState) {
    this.cache.set(viewState.session_id, {
      state: viewState,
      timestamp: Date.now()
    });
  }
  
  clear(sessionId?: string) {
    if (sessionId) {
      this.cache.delete(sessionId);
    } else {
      this.cache.clear();
    }
  }
}
```

## Post-Migration Checklist

After completing the migration, verify:

- [ ] All response types are handled correctly
- [ ] ViewState is updated on every API call  
- [ ] Sources are displayed for user trust
- [ ] Plan steps are shown with actionable UI
- [ ] Error handling uses structured error format
- [ ] Session and case IDs are tracked properly
- [ ] Performance metrics are within acceptable ranges
- [ ] Rollback mechanism is available if needed
- [ ] Unit tests cover all response scenarios
- [ ] Integration tests verify end-to-end workflows
- [ ] Documentation is updated for the new format
- [ ] Team training is completed for v3.1.0 concepts

## Support and Resources

For additional help during migration:

- **Schema Guide**: [v3.1.0-SCHEMA-GUIDE.md](./v3.1.0-SCHEMA-GUIDE.md)
- **API Reference**: [README.md](./README.md) 
- **Architecture Documentation**: [../architecture/SYSTEM_ARCHITECTURE.md](../architecture/SYSTEM_ARCHITECTURE.md)
- **Support**: Create issues in the repository for migration-specific problems

The migration to v3.1.0 provides significant benefits in terms of structured responses, evidence attribution, and improved user experience. Following this guide ensures a smooth transition while maintaining backward compatibility during the migration period.