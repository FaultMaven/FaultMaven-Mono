# FaultMaven v3.1.0 API Schema Guide

## Overview

The FaultMaven v3.1.0 schema represents a major evolution in the API design, moving from a legacy response format to a modern, intent-driven, evidence-based approach. This guide provides comprehensive documentation for developers working with the new schema.

## Key Improvements in v3.1.0

- **Intent-Driven Responses**: Explicit `ResponseType` enables optimal frontend rendering
- **Evidence Attribution**: Structured `Source` objects build user trust and verifiability
- **State Management**: `ViewState` eliminates need for separate API calls
- **Session vs Case Distinction**: Clear separation between temporary sessions and persistent investigations
- **Plan Validation**: Structured multi-step troubleshooting workflows
- **Backward Compatibility**: Legacy endpoints continue to work alongside new schema

## Core Schema Concepts

### Session vs Case Distinction

Understanding the difference between sessions and cases is crucial for proper API usage:

**session_id**
- **Purpose**: Short-lived visitor pass for temporary connections
- **Lifecycle**: Created per browser session, expires after inactivity
- **Scope**: Spans multiple investigations within a single user session
- **Example**: `sess_abc123def456`

**case_id** 
- **Purpose**: Long-lived case file number for persistent investigations
- **Lifecycle**: Created per investigation, persists for audit and follow-up
- **Scope**: Single investigation from start to resolution
- **Example**: `case_789ghi012jkl`

### Response Types

The `ResponseType` enum explicitly defines the agent's intent for each response:

| Type | Purpose | UI Rendering | Plan Field |
|------|---------|--------------|------------|
| `answer` | Direct response to user's question | Display as conversational message | Not allowed |
| `plan_proposal` | Multi-step troubleshooting plan | Show as structured steps with actions | Required |
| `clarification_request` | Agent needs more information | Prompt user for additional input | Not allowed |
| `confirmation_request` | Agent needs user approval | Show confirmation dialog | Not allowed |

### Evidence Sources

All responses include `sources` for transparency and trust:

| Source Type | Description | Example Name | Typical Snippet |
|-------------|-------------|--------------|-----------------|
| `knowledge_base` | From ingested documentation | "database_runbook.md" | "Connection pool exhaustion indicates..." |
| `log_file` | From uploaded logs | "application.log" | "ERROR: Connection timeout after 30s" |
| `web_search` | From web research | "Stack Overflow" | "This error typically occurs when..." |

## API Endpoints

### Primary Endpoint: POST /api/v1/agent/query

**Purpose**: Process troubleshooting queries using v3.1.0 schema

**Request Format**:
```json
{
  "session_id": "sess_abc123def456",
  "query": "Why am I getting HTTP 500 errors in production?"
}
```

**Response Format**: See [Response Examples](#response-examples) below.

### Legacy Compatibility: POST /api/v1/agent/troubleshoot

**Purpose**: Maintain compatibility with existing clients
**Behavior**: Internally uses v3.1.0 processing, converts response to legacy format
**Migration Path**: Update clients to use `/query` endpoint for full v3.1.0 benefits

## Response Examples

### ANSWER Response Example

Used for direct answers to user questions:

```json
{
  "schema_version": "3.1.0",
  "content": "The HTTP 500 errors are caused by database connection pool exhaustion. Your application has reached the maximum number of database connections (20) and cannot establish new connections, causing requests to fail with internal server errors.",
  "response_type": "answer",
  "view_state": {
    "session_id": "sess_abc123def456",
    "case_id": "case_789ghi012jkl",
    "running_summary": "Investigating HTTP 500 errors in production API. Root cause identified as database connection pool exhaustion affecting user requests.",
    "uploaded_data": [
      {
        "id": "data_upload_001",
        "name": "application.log",
        "type": "log_file"
      },
      {
        "id": "data_upload_002", 
        "name": "database_metrics.json",
        "type": "metrics"
      }
    ]
  },
  "sources": [
    {
      "type": "log_file",
      "name": "application.log",
      "snippet": "2025-01-15 14:23:45 ERROR [pool-1-thread-1] ConnectionPool: Cannot get connection, pool exhausted. Active: 20, Max: 20"
    },
    {
      "type": "knowledge_base", 
      "name": "database_troubleshooting_guide.md",
      "snippet": "Connection pool exhaustion occurs when activeCount equals maxActive and indicates insufficient pool size or connection leaks"
    },
    {
      "type": "web_search",
      "name": "Spring Boot Documentation",
      "snippet": "HikariCP connection pool can be configured with spring.datasource.hikari.maximum-pool-size property"
    }
  ]
}
```

### PLAN_PROPOSAL Response Example

Used when the agent proposes a structured multi-step solution:

```json
{
  "schema_version": "3.1.0",
  "content": "I've identified database connection pool exhaustion as the root cause of your HTTP 500 errors. Here's a structured plan to resolve this issue and prevent recurrence:",
  "response_type": "plan_proposal",
  "view_state": {
    "session_id": "sess_abc123def456",
    "case_id": "case_789ghi012jkl", 
    "running_summary": "HTTP 500 errors caused by connection pool exhaustion. Multi-step resolution plan prepared including immediate fix and preventive measures.",
    "uploaded_data": [
      {
        "id": "data_upload_001",
        "name": "application.log", 
        "type": "log_file"
      }
    ]
  },
  "sources": [
    {
      "type": "knowledge_base",
      "name": "incident_response_playbook.md",
      "snippet": "For immediate connection pool relief, increase pool size by 150% and monitor for 15 minutes before investigating leaks"
    },
    {
      "type": "log_file",
      "name": "application.log",
      "snippet": "Pattern detected: 47 connection timeout errors in last 5 minutes, all during peak load hours"
    }
  ],
  "plan": [
    {
      "description": "Immediately increase database connection pool size from 20 to 50 connections in production configuration"
    },
    {
      "description": "Monitor application response times and error rates for 10 minutes to confirm resolution"
    },
    {
      "description": "Review application logs for connection leak patterns and long-running transactions"
    },
    {
      "description": "Implement connection pool monitoring alerts with thresholds: 80% usage = warning, 95% usage = critical"
    },
    {
      "description": "Schedule follow-up review of database query performance and connection usage patterns"
    }
  ]
}
```

### CLARIFICATION_REQUEST Response Example

Used when the agent needs more information:

```json
{
  "schema_version": "3.1.0",
  "content": "I see you're experiencing HTTP 500 errors. To help diagnose this issue effectively, I need some additional information about your environment and the specific symptoms you're observing.",
  "response_type": "clarification_request", 
  "view_state": {
    "session_id": "sess_abc123def456",
    "case_id": "case_789ghi012jkl",
    "running_summary": "User reported HTTP 500 errors. Gathering additional context to narrow down potential causes.",
    "uploaded_data": []
  },
  "sources": [
    {
      "type": "knowledge_base",
      "name": "troubleshooting_methodology.md",
      "snippet": "HTTP 500 errors can stem from application code, database issues, memory problems, or external service failures. Context is key for diagnosis."
    }
  ]
}
```

### CONFIRMATION_REQUEST Response Example

Used when the agent needs user approval before proceeding:

```json
{
  "schema_version": "3.1.0", 
  "content": "I've identified that restarting the database connection pool will likely resolve your HTTP 500 errors. This action may cause a brief service interruption (5-10 seconds). Would you like me to proceed with this recommendation?",
  "response_type": "confirmation_request",
  "view_state": {
    "session_id": "sess_abc123def456",
    "case_id": "case_789ghi012jkl",
    "running_summary": "Connection pool exhaustion identified. Waiting for user confirmation to proceed with connection pool restart.",
    "uploaded_data": []
  },
  "sources": [
    {
      "type": "knowledge_base",
      "name": "connection_pool_management.md", 
      "snippet": "Connection pool restarts cause brief downtime but immediately clear stuck connections and restore service"
    }
  ]
}
```

## Error Handling

### Error Response Format

All errors use the standardized v3.1.0 error format:

```json
{
  "schema_version": "3.1.0",
  "error": {
    "code": "SESSION_NOT_FOUND",
    "message": "The specified session ID does not exist or has expired"
  }
}
```

### Common Error Codes

| Code | HTTP Status | Description | Action |
|------|-------------|-------------|--------|
| `SESSION_NOT_FOUND` | 404 | Session doesn't exist | Create new session |
| `CASE_NOT_FOUND` | 404 | Case ID invalid | Check case ID format |
| `INVALID_REQUEST` | 400 | Request validation failed | Fix request format |
| `QUERY_TOO_LONG` | 400 | Query exceeds limit | Shorten query text |
| `RATE_LIMIT_EXCEEDED` | 429 | Too many requests | Implement backoff |
| `SERVICE_UNAVAILABLE` | 503 | Backend service down | Retry later |

## Frontend Integration Patterns

### Basic Query Flow

```typescript
// TypeScript example for frontend integration
interface QueryRequest {
  session_id: string;
  query: string;
}

interface AgentResponse {
  schema_version: "3.1.0";
  content: string;
  response_type: "answer" | "plan_proposal" | "clarification_request" | "confirmation_request";
  view_state: ViewState;
  sources?: Source[];
  plan?: PlanStep[];
}

async function queryAgent(sessionId: string, query: string): Promise<AgentResponse> {
  const response = await fetch('/api/v1/agent/query', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      session_id: sessionId,
      query: query
    })
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`API Error: ${error.error.message}`);
  }

  return response.json();
}
```

### Response Type Handling

```typescript
function handleAgentResponse(response: AgentResponse) {
  switch (response.response_type) {
    case "answer":
      // Display as regular chat message with sources
      displayAnswer(response.content, response.sources);
      break;
      
    case "plan_proposal":
      // Show structured plan with actionable steps
      displayPlan(response.content, response.plan, response.sources);
      break;
      
    case "clarification_request":
      // Show form or prompt for additional information
      showClarificationPrompt(response.content);
      break;
      
    case "confirmation_request":
      // Show confirmation dialog with approve/deny options
      showConfirmationDialog(response.content);
      break;
  }
  
  // Always update view state for session tracking
  updateViewState(response.view_state);
}
```

### ViewState Management

```typescript
interface ViewState {
  session_id: string;
  case_id: string;
  running_summary: string;
  uploaded_data: UploadedData[];
}

function updateViewState(viewState: ViewState) {
  // Update current case information
  document.getElementById('case-id').textContent = viewState.case_id;
  document.getElementById('summary').textContent = viewState.running_summary;
  
  // Update uploaded data list
  const dataList = document.getElementById('uploaded-data');
  dataList.innerHTML = '';
  viewState.uploaded_data.forEach(data => {
    const item = document.createElement('li');
    item.textContent = `${data.name} (${data.type})`;
    dataList.appendChild(item);
  });
}
```

## Best Practices

### 1. Always Handle All Response Types

Ensure your frontend can handle all four response types appropriately:

```typescript
// ✅ Good - Handles all response types
function handleResponse(response: AgentResponse) {
  switch (response.response_type) {
    case "answer":
      return displayAnswer(response);
    case "plan_proposal": 
      return displayPlan(response);
    case "clarification_request":
      return showClarificationForm(response);
    case "confirmation_request":
      return showConfirmationDialog(response);
    default:
      console.error('Unknown response type:', response.response_type);
  }
}

// ❌ Bad - Missing response types
function handleResponse(response: AgentResponse) {
  if (response.response_type === "answer") {
    displayAnswer(response);
  }
  // Missing other response types!
}
```

### 2. Validate Plan Field Consistency

The `plan` field should only be present for `plan_proposal` responses:

```typescript
// ✅ Good - Validates plan consistency  
function validateResponse(response: AgentResponse): boolean {
  if (response.response_type === "plan_proposal") {
    return response.plan && response.plan.length > 0;
  } else {
    return !response.plan; // plan should not exist for other types
  }
}
```

### 3. Display Sources for Trust

Always show source attribution to build user trust:

```typescript
// ✅ Good - Shows sources with content
function displayAnswer(content: string, sources: Source[]) {
  const answerElement = document.createElement('div');
  answerElement.innerHTML = `
    <p>${content}</p>
    <div class="sources">
      <h4>Sources:</h4>
      <ul>
        ${sources.map(source => `
          <li>
            <strong>${source.name}</strong> (${source.type})
            <p><em>"${source.snippet}"</em></p>
          </li>
        `).join('')}
      </ul>
    </div>
  `;
}
```

### 4. Implement Proper Error Handling

Handle both API errors and validation errors gracefully:

```typescript
// ✅ Good - Comprehensive error handling
async function queryAgent(sessionId: string, query: string) {
  try {
    const response = await fetch('/api/v1/agent/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, query })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      if (response.status === 404 && errorData.error.code === 'SESSION_NOT_FOUND') {
        // Handle expired session
        return await createNewSessionAndRetry(query);
      }
      throw new Error(errorData.error.message);
    }
    
    const agentResponse = await response.json();
    
    // Validate response structure
    if (!validateResponse(agentResponse)) {
      throw new Error('Invalid response format');
    }
    
    return agentResponse;
    
  } catch (error) {
    console.error('Query failed:', error);
    showErrorMessage('Unable to process query. Please try again.');
    throw error;
  }
}
```

### 5. Preserve Session Context

Use ViewState to maintain context across interactions:

```typescript
// ✅ Good - Preserves context between queries
class FaultMavenClient {
  private currentViewState: ViewState | null = null;
  
  async query(query: string): Promise<AgentResponse> {
    const sessionId = this.currentViewState?.session_id || await this.createSession();
    
    const response = await queryAgent(sessionId, query);
    
    // Always update stored view state
    this.currentViewState = response.view_state;
    
    return response;
  }
  
  getCurrentCase(): string | null {
    return this.currentViewState?.case_id || null;
  }
  
  getSummary(): string | null {
    return this.currentViewState?.running_summary || null;
  }
}
```

## Migration from Legacy API

### Step 1: Update Endpoints

Change from legacy troubleshoot endpoint to new query endpoint:

```typescript
// ❌ Old - Legacy endpoint
const response = await fetch('/api/v1/agent/troubleshoot', {
  method: 'POST',
  body: JSON.stringify({ session_id: sessionId, query: query })
});

// ✅ New - v3.1.0 endpoint  
const response = await fetch('/api/v1/agent/query', {
  method: 'POST',
  body: JSON.stringify({ session_id: sessionId, query: query })
});
```

### Step 2: Update Response Handling

Migrate from legacy response format to new schema:

```typescript
// ❌ Old - Legacy response handling
interface LegacyResponse {
  investigation_id: string;
  status: string;
  findings: Finding[];
  recommendations: string[];
  // ... other legacy fields
}

function handleLegacyResponse(response: LegacyResponse) {
  displayFindings(response.findings);
  displayRecommendations(response.recommendations);
}

// ✅ New - v3.1.0 response handling
function handleAgentResponse(response: AgentResponse) {
  switch (response.response_type) {
    case "answer":
      displayContent(response.content, response.sources);
      break;
    case "plan_proposal":
      displayPlan(response.plan, response.sources);
      break;
    // ... handle other response types
  }
  
  updateViewState(response.view_state);
}
```

### Step 3: Implement ViewState Management

Add state tracking that wasn't available in legacy format:

```typescript
// ✅ New - ViewState management
interface AppState {
  currentSession: string | null;
  currentCase: string | null;
  investigationSummary: string;
  uploadedFiles: UploadedData[];
}

function updateAppState(viewState: ViewState) {
  const appState: AppState = {
    currentSession: viewState.session_id,
    currentCase: viewState.case_id,
    investigationSummary: viewState.running_summary,
    uploadedFiles: viewState.uploaded_data
  };
  
  // Save to localStorage for persistence
  localStorage.setItem('faultmaven_state', JSON.stringify(appState));
}
```

### Step 4: Gradual Migration Strategy

For large codebases, implement gradual migration:

```typescript
// Migration adapter for gradual transition
class MigrationAdapter {
  private useV3Schema: boolean;
  
  constructor(useV3Schema = false) {
    this.useV3Schema = useV3Schema;
  }
  
  async query(sessionId: string, query: string) {
    if (this.useV3Schema) {
      return this.queryV3(sessionId, query);
    } else {
      return this.queryLegacy(sessionId, query);
    }
  }
  
  private async queryV3(sessionId: string, query: string): Promise<AgentResponse> {
    // New v3.1.0 implementation
    const response = await fetch('/api/v1/agent/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, query })
    });
    return response.json();
  }
  
  private async queryLegacy(sessionId: string, query: string) {
    // Legacy implementation for backward compatibility
    const response = await fetch('/api/v1/agent/troubleshoot', {
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, query })
    });
    return response.json();
  }
}

// Enable v3.1.0 schema per component/feature
const adapter = new MigrationAdapter(true); // Enable v3.1.0 for this component
```

## Performance Considerations

### 1. Source Attribution Impact

The v3.1.0 schema includes more detailed source information. Consider this in your UI design:

```typescript
// ✅ Efficient - Lazy load source details
function displaySources(sources: Source[]) {
  const sourcesContainer = document.createElement('div');
  sourcesContainer.className = 'sources-collapsed';
  
  const summaryElement = document.createElement('button');
  summaryElement.textContent = `${sources.length} sources`;
  summaryElement.onclick = () => toggleSourceDetails(sourcesContainer);
  
  const detailsElement = document.createElement('div');
  detailsElement.className = 'sources-details hidden';
  detailsElement.innerHTML = sources.map(renderSourceDetail).join('');
  
  sourcesContainer.appendChild(summaryElement);
  sourcesContainer.appendChild(detailsElement);
  
  return sourcesContainer;
}
```

### 2. ViewState Caching

Cache ViewState to avoid redundant API calls:

```typescript
// ✅ Efficient - Cache view state
class ViewStateCache {
  private cache = new Map<string, ViewState>();
  private cacheExpiry = 5 * 60 * 1000; // 5 minutes
  
  get(sessionId: string): ViewState | null {
    const cached = this.cache.get(sessionId);
    if (cached && this.isValid(cached)) {
      return cached;
    }
    return null;
  }
  
  set(viewState: ViewState) {
    this.cache.set(viewState.session_id, {
      ...viewState,
      _cached_at: Date.now()
    });
  }
  
  private isValid(viewState: any): boolean {
    return (Date.now() - viewState._cached_at) < this.cacheExpiry;
  }
}
```

## Testing

### Unit Tests for Response Handling

```typescript
// Example unit tests for v3.1.0 schema handling
describe('v3.1.0 Response Handling', () => {
  test('handles ANSWER response type', () => {
    const response: AgentResponse = {
      schema_version: "3.1.0",
      content: "Test answer",
      response_type: "answer",
      view_state: mockViewState,
      sources: [mockSource]
    };
    
    const result = handleAgentResponse(response);
    expect(result.type).toBe('answer');
    expect(result.sources).toHaveLength(1);
  });
  
  test('validates plan consistency for PLAN_PROPOSAL', () => {
    const response: AgentResponse = {
      schema_version: "3.1.0",
      content: "Test plan",
      response_type: "plan_proposal",
      view_state: mockViewState,
      sources: [],
      plan: [{ description: "Step 1" }]
    };
    
    expect(validateResponse(response)).toBe(true);
  });
  
  test('rejects plan field for non-PLAN_PROPOSAL responses', () => {
    const response: AgentResponse = {
      schema_version: "3.1.0",
      content: "Test answer", 
      response_type: "answer",
      view_state: mockViewState,
      sources: [],
      plan: [{ description: "Should not exist" }] // Invalid
    };
    
    expect(validateResponse(response)).toBe(false);
  });
});
```

### Integration Tests

```typescript
// Example integration test
describe('v3.1.0 API Integration', () => {
  test('complete query workflow', async () => {
    const sessionId = await createTestSession();
    
    // Send query
    const response = await queryAgent(sessionId, 'Test query');
    
    // Verify response structure
    expect(response.schema_version).toBe('3.1.0');
    expect(response.response_type).toBeOneOf(['answer', 'plan_proposal', 'clarification_request', 'confirmation_request']);
    expect(response.view_state.session_id).toBe(sessionId);
    expect(response.view_state.case_id).toMatch(/^case_/);
    
    // Verify plan consistency
    if (response.response_type === 'plan_proposal') {
      expect(response.plan).toBeDefined();
      expect(response.plan.length).toBeGreaterThan(0);
    } else {
      expect(response.plan).toBeUndefined();
    }
  });
});
```

## Conclusion

The v3.1.0 schema provides a robust, intent-driven API that enables rich frontend experiences while maintaining backward compatibility. By following this guide and implementing the recommended patterns, you can build applications that fully leverage the structured, evidence-based responses from the FaultMaven AI agent.

For additional support and examples, refer to:
- [API Documentation](./README.md)
- [Migration Guide](./v3.1.0-MIGRATION-GUIDE.md)  
- [Architecture Documentation](../architecture/SYSTEM_ARCHITECTURE.md)