# FaultMaven v3.1.0 Schema Troubleshooting Guide

## Overview

This guide helps developers diagnose and resolve common issues when working with the FaultMaven v3.1.0 API schema. It covers validation errors, integration problems, performance issues, and debugging techniques.

## Quick Diagnostics

### Schema Validation Checklist

Before diving into specific issues, run through this quick checklist:

- [ ] Response includes `schema_version: "3.1.0"`
- [ ] `response_type` is one of the four valid enum values
- [ ] `plan` field only exists for `PLAN_PROPOSAL` responses  
- [ ] `view_state` contains all required fields
- [ ] `sources` array contains valid `Source` objects
- [ ] Error responses use structured `ErrorResponse` format

### Common Symptoms and Quick Fixes

| Symptom | Likely Cause | Quick Fix |
|---------|--------------|-----------|
| Frontend crashes on response | Plan consistency violation | Check plan field validation |
| "Unknown response type" errors | Invalid ResponseType value | Verify enum values |
| Missing evidence attribution | Sources not being extracted | Check source extraction logic |
| Session state out of sync | ViewState not being updated | Always update ViewState |
| Validation errors on requests | Missing required fields | Validate QueryRequest structure |

## Schema Validation Issues

### Issue 1: Plan Consistency Violations

**Symptoms:**
- Pydantic validation errors about plan field
- Frontend crashes when processing responses
- "Plan must be provided for PLAN_PROPOSAL" errors

**Root Causes:**
```python
# ❌ Wrong - Plan field without PLAN_PROPOSAL type
AgentResponse(
    response_type=ResponseType.ANSWER,
    plan=[PlanStep(description="Step 1")]  # Invalid!
)

# ❌ Wrong - PLAN_PROPOSAL without plan field  
AgentResponse(
    response_type=ResponseType.PLAN_PROPOSAL,
    plan=None  # Invalid!
)
```

**Solutions:**

```python
# ✅ Correct - Conditional plan creation
def build_response(content: str, agent_result: dict) -> AgentResponse:
    response_type = determine_response_type(agent_result)
    
    # Only create plan for PLAN_PROPOSAL
    plan = None
    if response_type == ResponseType.PLAN_PROPOSAL:
        next_steps = agent_result.get('next_steps', [])
        if next_steps:
            plan = [PlanStep(description=step) for step in next_steps]
        else:
            # If no steps available, change to ANSWER type
            response_type = ResponseType.ANSWER
    
    return AgentResponse(
        schema_version="3.1.0",
        content=content,
        response_type=response_type,
        view_state=create_view_state(),
        plan=plan  # Will be None for non-PLAN_PROPOSAL types
    )
```

**Debugging Commands:**
```python
# Validate response before sending
def validate_response_consistency(response: AgentResponse) -> bool:
    if response.response_type == ResponseType.PLAN_PROPOSAL:
        return response.plan is not None and len(response.plan) > 0
    else:
        return response.plan is None

# Test validation
response = build_response("Test content", test_result)
assert validate_response_consistency(response), "Plan consistency check failed"
```

### Issue 2: Invalid Response Types

**Symptoms:**
- "Unknown response type" logs in frontend
- API validation errors
- Enum value errors

**Root Causes:**
```python
# ❌ Wrong - Invalid enum value
AgentResponse(
    response_type="direct_answer"  # Not a valid ResponseType!
)

# ❌ Wrong - Case sensitivity issues
AgentResponse(
    response_type="ANSWER"  # Should be lowercase
)
```

**Solutions:**

```python
# ✅ Correct - Use enum values
from faultmaven.models.api import ResponseType

def determine_response_type(agent_result: dict) -> ResponseType:
    """Determine response type with proper enum handling"""
    
    # Use actual enum values
    if has_multiple_steps(agent_result):
        return ResponseType.PLAN_PROPOSAL
    elif needs_clarification(agent_result):
        return ResponseType.CLARIFICATION_REQUEST  
    elif needs_confirmation(agent_result):
        return ResponseType.CONFIRMATION_REQUEST
    else:
        return ResponseType.ANSWER  # Default

def has_multiple_steps(agent_result: dict) -> bool:
    next_steps = agent_result.get('next_steps', [])
    return isinstance(next_steps, list) and len(next_steps) > 1

def needs_clarification(agent_result: dict) -> bool:
    content = agent_result.get('content', '').lower()
    clarification_keywords = [
        'need more information',
        'can you provide',
        'please share',
        'what is the',
        'could you clarify'
    ]
    return any(keyword in content for keyword in clarification_keywords)
```

**Testing Response Types:**
```python
# Unit test for response type determination
def test_response_type_determination():
    # Test PLAN_PROPOSAL
    result_with_steps = {'next_steps': ['Step 1', 'Step 2', 'Step 3']}
    assert determine_response_type(result_with_steps) == ResponseType.PLAN_PROPOSAL
    
    # Test CLARIFICATION_REQUEST  
    result_needs_info = {'content': 'I need more information about your setup'}
    assert determine_response_type(result_needs_info) == ResponseType.CLARIFICATION_REQUEST
    
    # Test ANSWER (default)
    result_direct = {'content': 'The issue is database connectivity'}
    assert determine_response_type(result_direct) == ResponseType.ANSWER
```

### Issue 3: ViewState Construction Errors

**Symptoms:**
- Missing case_id in responses
- Empty or invalid ViewState fields
- Frontend state synchronization issues

**Root Causes:**
```python
# ❌ Wrong - Missing required ViewState fields
ViewState(
    session_id="sess_123"
    # Missing case_id, running_summary, uploaded_data
)

# ❌ Wrong - Invalid field types
ViewState(
    session_id="sess_123",
    case_id="case_456", 
    running_summary=None,  # Should be string
    uploaded_data="none"   # Should be list
)
```

**Solutions:**

```python
# ✅ Correct - Complete ViewState construction
async def create_view_state(
    session_id: str,
    case_id: str,
    agent_result: dict,
    query: str
) -> ViewState:
    """Create properly structured ViewState"""
    
    # Generate meaningful summary
    summary = generate_investigation_summary(agent_result, query)
    
    # Get uploaded data for this session
    uploaded_data = await get_session_uploaded_data(session_id)
    
    return ViewState(
        session_id=session_id,
        case_id=case_id,
        running_summary=summary,
        uploaded_data=uploaded_data or []  # Ensure it's always a list
    )

def generate_investigation_summary(agent_result: dict, query: str) -> str:
    """Generate concise investigation summary"""
    
    # Truncate query if too long
    query_summary = query[:50] + "..." if len(query) > 50 else query
    
    # Extract key finding or root cause
    root_cause = agent_result.get('root_cause')
    findings = agent_result.get('findings', [])
    
    if root_cause:
        return f"Investigating: {query_summary} | Root cause: {root_cause[:100]}"
    elif findings:
        first_finding = findings[0].get('message', '') if isinstance(findings[0], dict) else str(findings[0])
        return f"Investigating: {query_summary} | Found: {first_finding[:100]}"
    else:
        return f"Investigating: {query_summary}"

async def get_session_uploaded_data(session_id: str) -> List[UploadedData]:
    """Get uploaded data for session with proper error handling"""
    try:
        # Query session service for uploaded data
        data_records = await session_service.get_uploaded_data(session_id)
        
        return [
            UploadedData(
                id=record.id,
                name=record.filename,
                type=record.data_type
            ) for record in data_records
        ]
    except Exception as e:
        logger.warning(f"Failed to get uploaded data for session {session_id}: {e}")
        return []  # Return empty list on error
```

## Integration Issues

### Issue 4: Frontend Response Handling

**Symptoms:**
- Frontend doesn't update UI based on response type
- Missing source attribution display
- ViewState not being synchronized

**Root Causes:**
- Missing response type handlers
- Not processing ViewState updates
- Ignoring sources array

**Solutions:**

```typescript
// ✅ Correct - Comprehensive response handling
interface ResponseHandler {
  handleResponse(response: AgentResponse): void;
}

class FaultMavenResponseHandler implements ResponseHandler {
  
  handleResponse(response: AgentResponse): void {
    // Validate response structure first
    if (!this.isValidResponse(response)) {
      console.error('Invalid response structure:', response);
      this.handleInvalidResponse();
      return;
    }
    
    // Always update ViewState first
    this.updateViewState(response.view_state);
    
    // Handle based on response type
    switch (response.response_type) {
      case 'answer':
        this.handleAnswer(response);
        break;
      case 'plan_proposal':
        this.handlePlanProposal(response);
        break;
      case 'clarification_request':
        this.handleClarificationRequest(response);
        break;
      case 'confirmation_request':
        this.handleConfirmationRequest(response);
        break;
      default:
        console.warn('Unknown response type:', response.response_type);
        this.handleAnswer(response); // Fallback to answer display
    }
  }
  
  private isValidResponse(response: any): response is AgentResponse {
    return (
      response &&
      response.schema_version === '3.1.0' &&
      typeof response.content === 'string' &&
      response.response_type &&
      response.view_state &&
      response.view_state.session_id &&
      response.view_state.case_id
    );
  }
  
  private handleAnswer(response: AgentResponse): void {
    // Verify no plan field for ANSWER type
    if (response.plan) {
      console.warn('ANSWER response should not have plan field');
    }
    
    this.displayContent(response.content);
    this.displaySources(response.sources || []);
  }
  
  private handlePlanProposal(response: AgentResponse): void {
    // Verify plan field exists for PLAN_PROPOSAL
    if (!response.plan || response.plan.length === 0) {
      console.error('PLAN_PROPOSAL response missing plan field');
      this.handleAnswer(response); // Fallback
      return;
    }
    
    this.displayContent(response.content);
    this.displayPlan(response.plan);
    this.displaySources(response.sources || []);
  }
  
  private updateViewState(viewState: ViewState): void {
    // Update UI elements
    const caseElement = document.getElementById('current-case');
    const summaryElement = document.getElementById('investigation-summary');
    const dataListElement = document.getElementById('uploaded-data-list');
    
    if (caseElement) caseElement.textContent = viewState.case_id;
    if (summaryElement) summaryElement.textContent = viewState.running_summary;
    
    if (dataListElement) {
      dataListElement.innerHTML = '';
      viewState.uploaded_data.forEach(data => {
        const item = document.createElement('li');
        item.innerHTML = `<span class="data-name">${data.name}</span> <span class="data-type">(${data.type})</span>`;
        dataListElement.appendChild(item);
      });
    }
    
    // Store in session storage for persistence
    sessionStorage.setItem('faultmaven_view_state', JSON.stringify(viewState));
  }
}
```

### Issue 5: API Error Handling

**Symptoms:**
- Unhandled error responses
- Frontend shows generic error messages
- No structured error handling

**Root Causes:**
- Not using structured ErrorResponse format
- Missing error code handling
- No retry logic for recoverable errors

**Solutions:**

```typescript
// ✅ Correct - Structured error handling
interface ErrorResponse {
  schema_version: "3.1.0";
  error: {
    code: string;
    message: string;
  };
}

class APIErrorHandler {
  
  async handleAPICall(apiCall: () => Promise<Response>): Promise<AgentResponse> {
    try {
      const response = await apiCall();
      
      if (!response.ok) {
        const errorData: ErrorResponse = await response.json();
        throw new StructuredAPIError(errorData.error.code, errorData.error.message, response.status);
      }
      
      const data: AgentResponse = await response.json();
      
      // Validate response structure
      if (!this.isValidAgentResponse(data)) {
        throw new ValidationError('Invalid response format received from API');
      }
      
      return data;
      
    } catch (error) {
      if (error instanceof StructuredAPIError) {
        return this.handleStructuredError(error);
      } else if (error instanceof ValidationError) {
        throw error; // Re-throw validation errors
      } else {
        throw new NetworkError('Failed to communicate with FaultMaven API', error);
      }
    }
  }
  
  private async handleStructuredError(error: StructuredAPIError): Promise<AgentResponse> {
    switch (error.code) {
      case 'SESSION_NOT_FOUND':
        // Automatically create new session and retry
        const newSessionId = await this.createNewSession();
        throw new RetryWithNewSessionError(newSessionId);
        
      case 'RATE_LIMIT_EXCEEDED':
        // Implement exponential backoff
        await this.delay(this.calculateBackoffDelay());
        throw new RetryableError('Rate limit exceeded, retrying...');
        
      case 'VALIDATION_ERROR':
        // Show user-friendly validation message
        throw new UserFacingError(`Request validation failed: ${error.message}`);
        
      case 'SERVICE_UNAVAILABLE':
        // Show service unavailable message with retry option
        throw new ServiceUnavailableError('FaultMaven service is temporarily unavailable');
        
      default:
        throw new UnknownAPIError(`API Error (${error.code}): ${error.message}`);
    }
  }
}

// Custom error classes
class StructuredAPIError extends Error {
  constructor(public code: string, message: string, public status: number) {
    super(message);
    this.name = 'StructuredAPIError';
  }
}

class RetryWithNewSessionError extends Error {
  constructor(public newSessionId: string) {
    super('Session expired, retry with new session');
    this.name = 'RetryWithNewSessionError';
  }
}
```

## Performance Issues

### Issue 6: Large Response Sizes

**Symptoms:**
- Slow API response times
- Network timeouts
- High memory usage in frontend

**Root Causes:**
- Too many sources in response
- Large source snippets  
- Verbose running summaries

**Solutions:**

```python
# ✅ Optimized source extraction
def extract_optimized_sources(agent_result: dict, max_sources: int = 3) -> List[Source]:
    """Extract sources with size optimization"""
    
    all_sources = []
    
    # Collect sources with confidence scores
    for kb_source in agent_result.get('knowledge_sources', []):
        confidence = kb_source.get('confidence', 0)
        if confidence > 0.7:  # Only high-confidence sources
            snippet = kb_source.get('relevant_excerpt', '')
            # Limit snippet size
            if len(snippet) > 150:
                snippet = snippet[:150] + "..."
            
            all_sources.append((confidence, Source(
                type=SourceType.KNOWLEDGE_BASE,
                name=kb_source['document_name'],
                snippet=snippet
            )))
    
    # Sort by confidence and take top sources
    all_sources.sort(key=lambda x: x[0], reverse=True)
    return [source for _, source in all_sources[:max_sources]]

def create_concise_summary(agent_result: dict, query: str, max_length: int = 200) -> str:
    """Create concise investigation summary"""
    
    query_part = query[:50] + "..." if len(query) > 50 else query
    
    # Extract most important finding
    findings = agent_result.get('findings', [])
    if findings and isinstance(findings[0], dict):
        key_finding = findings[0].get('message', '')[:80]
        summary = f"{query_part} | {key_finding}"
    else:
        summary = query_part
    
    return summary[:max_length] + "..." if len(summary) > max_length else summary
```

**Performance Monitoring:**

```python
# Add response size monitoring
def monitor_response_size(response: AgentResponse) -> None:
    """Monitor response sizes and log warnings"""
    
    response_json = response.json()
    total_size = len(response_json)
    
    sources_size = len(json.dumps(response.sources or []))
    view_state_size = len(json.dumps(response.view_state.dict()))
    
    metrics = {
        'total_size': total_size,
        'sources_size': sources_size, 
        'view_state_size': view_state_size,
        'sources_count': len(response.sources or []),
        'content_length': len(response.content)
    }
    
    logger.info(f"Response metrics: {metrics}")
    
    # Warn about large responses
    if total_size > 50000:  # 50KB
        logger.warning(f"Large response detected: {total_size} bytes")
    
    if len(response.sources or []) > 5:
        logger.warning(f"Many sources in response: {len(response.sources)} sources")
```

### Issue 7: ViewState Caching Issues

**Symptoms:**
- Stale ViewState information
- Duplicate API calls
- Inconsistent frontend state

**Solutions:**

```typescript
// ✅ ViewState caching with TTL
class ViewStateCache {
  private cache = new Map<string, CachedViewState>();
  private readonly TTL = 5 * 60 * 1000; // 5 minutes
  
  interface CachedViewState {
    viewState: ViewState;
    timestamp: number;
  }
  
  get(sessionId: string): ViewState | null {
    const cached = this.cache.get(sessionId);
    
    if (!cached) {
      return null;
    }
    
    // Check if expired
    if (Date.now() - cached.timestamp > this.TTL) {
      this.cache.delete(sessionId);
      return null;
    }
    
    return cached.viewState;
  }
  
  set(viewState: ViewState): void {
    this.cache.set(viewState.session_id, {
      viewState: { ...viewState }, // Deep copy
      timestamp: Date.now()
    });
  }
  
  invalidate(sessionId: string): void {
    this.cache.delete(sessionId);
  }
  
  clear(): void {
    this.cache.clear();
  }
}

// Usage with API calls
class FaultMavenClient {
  private viewStateCache = new ViewStateCache();
  
  async query(sessionId: string, query: string): Promise<AgentResponse> {
    const response = await this.apiCall(sessionId, query);
    
    // Always update cache with latest ViewState
    this.viewStateCache.set(response.view_state);
    
    return response;
  }
  
  getCachedViewState(sessionId: string): ViewState | null {
    return this.viewStateCache.get(sessionId);
  }
}
```

## Debugging Techniques

### Debug Response Structure

```python
# Debug response validation
def debug_response_structure(response: AgentResponse) -> Dict[str, Any]:
    """Debug response structure and return validation details"""
    
    debug_info = {
        'schema_version': response.schema_version,
        'has_content': bool(response.content),
        'content_length': len(response.content),
        'response_type': response.response_type,
        'has_view_state': response.view_state is not None,
        'sources_count': len(response.sources or []),
        'has_plan': response.plan is not None,
        'plan_steps': len(response.plan) if response.plan else 0
    }
    
    # Validate plan consistency
    plan_consistent = True
    if response.response_type == ResponseType.PLAN_PROPOSAL:
        if not response.plan or len(response.plan) == 0:
            plan_consistent = False
    else:
        if response.plan is not None:
            plan_consistent = False
    
    debug_info['plan_consistent'] = plan_consistent
    
    # Check ViewState completeness
    if response.view_state:
        debug_info['view_state_complete'] = all([
            response.view_state.session_id,
            response.view_state.case_id,
            response.view_state.running_summary,
            isinstance(response.view_state.uploaded_data, list)
        ])
    else:
        debug_info['view_state_complete'] = False
    
    return debug_info

# Usage in API routes for debugging
@router.post("/query")
async def query_with_debug(request: QueryRequest, debug: bool = False):
    response = await agent_service.process_query(request)
    
    if debug:
        debug_info = debug_response_structure(response)
        logger.info(f"Response debug info: {debug_info}")
        
        if not debug_info['plan_consistent']:
            logger.error("Plan consistency violation detected!")
        
        if not debug_info['view_state_complete']:
            logger.error("Incomplete ViewState detected!")
    
    return response
```

### Debug API Calls

```bash
# Debug API calls with curl
curl -X POST "http://localhost:8000/api/v1/cases/{case_id}/queries?debug=true" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "Test query for debugging"
  }' | jq .

# Check response structure
curl -X POST "http://localhost:8000/api/v1/cases/{case_id}/queries" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "Debug test"
  }' | jq 'keys'

# Expected output: ["content", "plan", "response_type", "schema_version", "sources", "view_state"]
```

### Debug Frontend Integration

```typescript
// Debug response processing
function debugResponseProcessing(response: any): void {
  console.group('FaultMaven Response Debug');
  
  // Check schema version
  console.log('Schema Version:', response.schema_version);
  if (response.schema_version !== '3.1.0') {
    console.error('❌ Wrong schema version!');
  }
  
  // Check response type
  console.log('Response Type:', response.response_type);
  const validTypes = ['answer', 'plan_proposal', 'clarification_request', 'confirmation_request'];
  if (!validTypes.includes(response.response_type)) {
    console.error('❌ Invalid response type!');
  }
  
  // Check plan consistency
  if (response.response_type === 'plan_proposal') {
    if (!response.plan || response.plan.length === 0) {
      console.error('❌ PLAN_PROPOSAL missing plan field!');
    } else {
      console.log('✅ Plan field present for PLAN_PROPOSAL');
    }
  } else {
    if (response.plan) {
      console.error('❌ Plan field present for non-PLAN_PROPOSAL type!');
    } else {
      console.log('✅ No plan field for non-PLAN_PROPOSAL type');
    }
  }
  
  // Check ViewState
  if (response.view_state) {
    console.log('ViewState:', {
      session_id: response.view_state.session_id,
      case_id: response.view_state.case_id,
      has_summary: !!response.view_state.running_summary,
      uploaded_data_count: response.view_state.uploaded_data?.length || 0
    });
  } else {
    console.error('❌ Missing ViewState!');
  }
  
  // Check sources
  console.log('Sources:', response.sources?.length || 0);
  if (response.sources) {
    response.sources.forEach((source: any, index: number) => {
      console.log(`  Source ${index + 1}:`, {
        type: source.type,
        name: source.name,
        snippet_length: source.snippet?.length || 0
      });
    });
  }
  
  console.groupEnd();
}

// Use in response handler
async function handleAPIResponse(response: Response): Promise<AgentResponse> {
  const data = await response.json();
  
  // Debug in development
  if (process.env.NODE_ENV === 'development') {
    debugResponseProcessing(data);
  }
  
  return data as AgentResponse;
}
```

## Common Error Messages and Solutions

### Error: "Plan must be provided for PLAN_PROPOSAL"

**Cause:** Response type is `PLAN_PROPOSAL` but `plan` field is missing or empty.

**Solution:**
```python
# Check for next_steps before setting PLAN_PROPOSAL type
def safe_response_type_determination(agent_result: dict) -> ResponseType:
    next_steps = agent_result.get('next_steps', [])
    if next_steps and len(next_steps) > 1:
        return ResponseType.PLAN_PROPOSAL
    else:
        return ResponseType.ANSWER
```

### Error: "Plan field not allowed for ANSWER response"

**Cause:** Response type is not `PLAN_PROPOSAL` but `plan` field is present.

**Solution:**
```python
# Conditional plan assignment
plan = None
if response_type == ResponseType.PLAN_PROPOSAL:
    plan = extract_plan_steps(agent_result)

return AgentResponse(
    # ... other fields
    response_type=response_type,
    plan=plan  # Will be None for non-PLAN_PROPOSAL types
)
```

### Error: "Invalid response format received from API"

**Cause:** Response is missing required fields or has wrong structure.

**Solution:**
```typescript
// Add comprehensive validation
function validateAgentResponse(data: any): data is AgentResponse {
  return (
    data &&
    data.schema_version === '3.1.0' &&
    typeof data.content === 'string' &&
    ['answer', 'plan_proposal', 'clarification_request', 'confirmation_request'].includes(data.response_type) &&
    data.view_state &&
    typeof data.view_state.session_id === 'string' &&
    typeof data.view_state.case_id === 'string' &&
    typeof data.view_state.running_summary === 'string' &&
    Array.isArray(data.view_state.uploaded_data)
  );
}
```

### Error: "Session not found"

**Cause:** Session has expired or doesn't exist.

**Solution:**
```typescript
// Automatic session recovery
async function handleSessionError(): Promise<string> {
  const newSessionId = await createNewSession();
  sessionStorage.setItem('faultmaven_session_id', newSessionId);
  return newSessionId;
}
```

## Testing and Validation

### Unit Test Templates

```python
# Test response structure
def test_response_structure():
    response = AgentResponse(
        schema_version="3.1.0",
        content="Test content",
        response_type=ResponseType.ANSWER,
        view_state=ViewState(
            session_id="test_session",
            case_id="test_case", 
            running_summary="Test summary",
            uploaded_data=[]
        ),
        sources=[],
        plan=None
    )
    
    # Validate structure
    assert response.schema_version == "3.1.0"
    assert response.response_type == ResponseType.ANSWER
    assert response.plan is None  # Should be None for ANSWER type

# Test plan consistency
@pytest.mark.parametrize("response_type,plan,should_pass", [
    (ResponseType.ANSWER, None, True),
    (ResponseType.PLAN_PROPOSAL, [PlanStep(description="Step 1")], True),
    (ResponseType.ANSWER, [PlanStep(description="Step 1")], False),  # Should fail
    (ResponseType.PLAN_PROPOSAL, None, False),  # Should fail
])
def test_plan_consistency(response_type, plan, should_pass):
    try:
        response = AgentResponse(
            schema_version="3.1.0",
            content="Test",
            response_type=response_type,
            view_state=create_test_view_state(),
            plan=plan
        )
        assert should_pass, "Should have raised validation error"
    except ValueError:
        assert not should_pass, "Should not have raised validation error"
```

### Integration Test Templates

```python
def test_full_api_workflow(client):
    # Test complete workflow
    response = client.post("/api/v1/cases/{case_id}/queries", json={
        "query": "Test query"
    })
    
    assert response.status_code == 200
    data = response.json()
    
    # Validate v3.1.0 structure
    assert data["schema_version"] == "3.1.0"
    assert "response_type" in data
    assert "view_state" in data
    
    # Validate plan consistency
    if data["response_type"] == "plan_proposal":
        assert "plan" in data and data["plan"]
    else:
        assert data.get("plan") is None
```

## Best Practices Summary

1. **Always validate response structure** before sending to frontend
2. **Use enum values** for response types, never string literals
3. **Implement plan consistency checks** in both backend and frontend
4. **Update ViewState** on every API response
5. **Handle all response types** in frontend code
6. **Provide meaningful sources** with concise snippets
7. **Monitor response sizes** to prevent performance issues
8. **Cache ViewState** appropriately with proper TTL
9. **Use structured error handling** for better UX
10. **Test plan consistency** thoroughly in unit tests

## Getting Help

- **Schema Guide**: [v3.1.0-SCHEMA-GUIDE.md](./v3.1.0-SCHEMA-GUIDE.md)
- **Migration Guide**: [v3.1.0-MIGRATION-GUIDE.md](./v3.1.0-MIGRATION-GUIDE.md)
- **API Documentation**: [README.md](./README.md)
- **Architecture Docs**: [../architecture/SYSTEM_ARCHITECTURE.md](../architecture/SYSTEM_ARCHITECTURE.md)

For specific issues not covered in this guide, create a GitHub issue with:
- Detailed error messages
- Request/response examples
- Steps to reproduce
- Expected vs actual behavior