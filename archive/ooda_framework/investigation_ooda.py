"""Investigation State Models for OODA Framework

This module defines the comprehensive investigation state models for FaultMaven's
OODA (Observe-Orient-Decide-Act) framework with 7 investigation phases.

Design Reference:
- docs/architecture/investigation-phases-and-ooda-integration.md
- docs/architecture/evidence-collection-and-tracking-design.md
- docs/architecture/case-lifecycle-management.md

Key Components:
- InvestigationState: Root state with 5 layers (Metadata, Lifecycle, OODA, Evidence, Memory)
- Investigation Phases: 7 phases (0-6) from Intake to Document
- OODA Engine: Observe-Orient-Decide-Act cycle management
- Hierarchical Memory: Hot/Warm/Cold memory tiers for token optimization
- Engagement Modes: Consultant vs Lead Investigator
"""

from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator


# =============================================================================
# Enums
# =============================================================================


class InvestigationPhase(int, Enum):
    """Investigation phases (0-indexed) in OODA framework

    7 phases from problem confirmation through documentation:
    - Phase 0: Intake (problem confirmation, Consultant mode)
    - Phase 1: Blast Radius (scope assessment, OODA begins)
    - Phase 2: Timeline (temporal context)
    - Phase 3: Hypothesis (theory generation)
    - Phase 4: Validation (hypothesis testing, full OODA)
    - Phase 5: Solution (fix application and verification)
    - Phase 6: Document (artifact generation)
    """
    INTAKE = 0          # Problem confirmation and consent
    BLAST_RADIUS = 1    # Impact scope assessment
    TIMELINE = 2        # Temporal context establishment
    HYPOTHESIS = 3      # Root cause theory generation
    VALIDATION = 4      # Systematic hypothesis testing
    SOLUTION = 5        # Fix implementation and verification
    DOCUMENT = 6        # Knowledge capture and artifacts


class OODAStep(str, Enum):
    """OODA framework steps for tactical execution

    4 steps defining HOW to investigate within each phase:
    - Observe: Gather information and evidence
    - Orient: Analyze and contextualize data
    - Decide: Choose action or hypothesis
    - Act: Execute test or apply solution
    """
    OBSERVE = "observe"    # ðŸ“Š Gather data and evidence
    ORIENT = "orient"      # ðŸ§­ Analyze and contextualize
    DECIDE = "decide"      # ðŸ’¡ Choose action/hypothesis
    ACT = "act"            # âš¡ Execute test/solution


class EngagementMode(str, Enum):
    """Agent engagement modes based on investigation state

    - Consultant: Expert colleague providing guidance (Phase 0)
    - Lead Investigator: War room lead driving resolution (Phases 1-6)
    """
    CONSULTANT = "consultant"              # Reactive, follows user lead
    LEAD_INVESTIGATOR = "lead_investigator"  # Proactive, guides methodology


class InvestigationStrategy(str, Enum):
    """Investigation approach - speed vs depth

    Selected when Lead Investigator Mode activated:
    - Active Incident: Speed priority, mitigation first
    - Post-Mortem: Thoroughness priority, complete RCA
    """
    ACTIVE_INCIDENT = "active_incident"  # Service down, prioritize mitigation
    POST_MORTEM = "post_mortem"          # Historical analysis, thoroughness


class HypothesisStatus(str, Enum):
    """Hypothesis lifecycle states (unified continuous generation model)"""
    CAPTURED = "captured"      # Early intuition captured opportunistically (Phases 0-2)
    ACTIVE = "active"          # Currently being tested (promoted from captured or systematic)
    VALIDATED = "validated"    # Confirmed by evidence (confidence â‰¥70% + â‰¥2 supporting evidence)
    REFUTED = "refuted"        # Disproved by evidence (confidence â‰¤20% + â‰¥2 refuting evidence)
    RETIRED = "retired"        # Abandoned (low confidence or anchoring)
    SUPERSEDED = "superseded"  # Better hypothesis found


class HypothesisGenerationMode(str, Enum):
    """How hypothesis was generated"""
    OPPORTUNISTIC = "opportunistic"  # Captured during early phases (Phases 0-2)
    SYSTEMATIC = "systematic"        # Generated systematically in Phase 3
    FORCED_ALTERNATIVE = "forced"    # Generated by anchoring prevention (v3.0)


class ConfidenceLevel(str, Enum):
    """Human-readable confidence levels for communication (v3.0)

    Maps confidence percentages to natural language for user communication.
    Agent uses these levels to transparently communicate investigation certainty.
    """
    SPECULATION = "speculation"  # < 50%: "I speculate that..."
    PROBABLE = "probable"        # 50-69%: "This is probably..."
    CONFIDENT = "confident"      # 70-89%: "I'm confident that..."
    VERIFIED = "verified"        # 90%+: "Verified:"


class InvestigationMomentum(str, Enum):
    """Investigation progress velocity (v3.0)"""
    HIGH = "high"        # Evidence flowing, confidence increasing
    MODERATE = "moderate"  # Some progress, steady state
    LOW = "low"          # Little progress, confidence plateaued
    BLOCKED = "blocked"  # Critical evidence unavailable


class DegradedModeType(str, Enum):
    """Types of degraded investigation modes with confidence caps (v3.0)

    When investigation cannot reach normal validation threshold (70%),
    system operates in degraded mode with capped confidence based on limitation type.
    """
    CRITICAL_EVIDENCE_MISSING = "critical_evidence_missing"  # 50% cap
    EXPERTISE_REQUIRED = "expertise_required"                # 40% cap
    SYSTEMIC_ISSUE = "systemic_issue"                        # 30% cap
    HYPOTHESIS_SPACE_EXHAUSTED = "hypothesis_space_exhausted"  # 0% cap (must close)
    GENERAL_LIMITATION = "general_limitation"                # 50% cap


def get_confidence_cap(degraded_mode_type: DegradedModeType) -> float:
    """Get confidence cap for degraded mode type

    Args:
        degraded_mode_type: Type of degraded mode limitation

    Returns:
        Maximum confidence achievable (0.0-0.5)
    """
    caps = {
        DegradedModeType.CRITICAL_EVIDENCE_MISSING: 0.50,
        DegradedModeType.EXPERTISE_REQUIRED: 0.40,
        DegradedModeType.SYSTEMIC_ISSUE: 0.30,
        DegradedModeType.HYPOTHESIS_SPACE_EXHAUSTED: 0.0,
        DegradedModeType.GENERAL_LIMITATION: 0.50,
    }
    return caps[degraded_mode_type]


# =============================================================================
# Phase-to-OODA Mapping (Weighted System)
# =============================================================================


@dataclass
class PhaseOODAProfile:
    """OODA step emphasis profile for an investigation phase

    **Architecture**: Single source of truth for OODA step weights per phase.
    Binary activation matrix is derived from these weights (weight > 0 = allowed).

    **Weight Semantics**:
    Weights represent RELATIVE EMPHASIS, not probabilities.
    They indicate how much time/effort should be spent on each step.

    Weight Interpretation:
    - 0.0: Not used in this phase
    - 0.01-0.10: Micro-actions (rare, tactical use only)
    - 0.11-0.30: Regular use (secondary focus)
    - 0.31-0.60: Primary focus (major emphasis)
    - 0.61-1.0: Dominant focus (almost exclusive)

    Weights don't need to sum to 1.0 (normalized internally for display).

    Examples:
        # Phase 1: Blast Radius (primary: observe+orient, tactical: decide, micro: act)
        PhaseOODAProfile(observe=0.60, orient=0.30, decide=0.08, act=0.02)

        # Phase 4: Validation (balanced full OODA)
        PhaseOODAProfile(observe=0.25, orient=0.25, decide=0.25, act=0.25)

    Design Reference:
    - docs/architecture/investigation-phases-and-ooda-integration.md
    """
    observe: float
    orient: float
    decide: float
    act: float

    def normalize(self) -> dict[str, float]:
        """Normalize weights to percentages (sum=1.0) for display

        Returns:
            Dictionary of normalized weights as percentages
        """
        total = self.observe + self.orient + self.decide + self.act
        if total == 0:
            return {"observe": 0.0, "orient": 0.0, "decide": 0.0, "act": 0.0}
        return {
            "observe": self.observe / total,
            "orient": self.orient / total,
            "decide": self.decide / total,
            "act": self.act / total,
        }

    def get_primary_steps(self) -> list[str]:
        """Steps with â‰¥30% normalized weight (primary focus)

        Returns:
            List of step names with primary focus
        """
        norm = self.normalize()
        return [step for step, weight in norm.items() if weight >= 0.30]

    def get_tactical_steps(self) -> list[str]:
        """Steps with 10-30% normalized weight (secondary focus)

        Returns:
            List of step names with tactical focus
        """
        norm = self.normalize()
        return [step for step, weight in norm.items() if 0.10 <= weight < 0.30]

    def get_micro_steps(self) -> list[str]:
        """Steps with <10% normalized weight (micro-actions only)

        Returns:
            List of step names for micro-actions
        """
        norm = self.normalize()
        return [step for step, weight in norm.items() if 0.0 < weight < 0.10]

    def is_step_allowed(self, step: OODAStep) -> bool:
        """Check if OODA step is allowed in this phase

        Args:
            step: OODA step to check

        Returns:
            True if step has non-zero weight (allowed)
        """
        weight = getattr(self, step.value)
        return weight > 0.0


# Phase-specific OODA weight profiles (single source of truth)
PHASE_OODA_WEIGHTS: dict[InvestigationPhase, PhaseOODAProfile] = {
    InvestigationPhase.INTAKE: PhaseOODAProfile(
        observe=0.50,  # Listen to problem description, detect signals
        orient=0.50,   # Contextualize urgency, recognize patterns
        decide=0.0,    # No investigation decisions yet
        act=0.0,       # No investigation actions yet
    ),
    InvestigationPhase.BLAST_RADIUS: PhaseOODAProfile(
        observe=0.60,  # Primary: gathering scope data
        orient=0.30,   # Secondary: understanding impact
        decide=0.08,   # Tactical: "check this specific metric"
        act=0.02,      # Micro-actions: quick diagnostic queries
    ),
    InvestigationPhase.TIMELINE: PhaseOODAProfile(
        observe=0.60,  # Primary: collecting timeline evidence
        orient=0.30,   # Secondary: correlating events
        decide=0.08,   # Tactical: "check deployment time"
        act=0.02,      # Micro-actions: query change logs
    ),
    InvestigationPhase.HYPOTHESIS: PhaseOODAProfile(
        observe=0.30,  # Supporting: reviewing evidence
        orient=0.35,   # Primary: pattern analysis
        decide=0.30,   # High: generating hypotheses
        act=0.05,      # Light: preliminary checks
    ),
    InvestigationPhase.VALIDATION: PhaseOODAProfile(
        observe=0.25,  # Full OODA cycle - balanced
        orient=0.25,
        decide=0.25,
        act=0.25,
    ),
    InvestigationPhase.SOLUTION: PhaseOODAProfile(
        observe=0.10,  # Light: monitoring effects
        orient=0.25,   # Verify results
        decide=0.30,   # Choose solution approach
        act=0.35,      # Primary: implementing fix
    ),
    InvestigationPhase.DOCUMENT: PhaseOODAProfile(
        observe=0.0,
        orient=1.0,    # Pure synthesis and artifact generation
        decide=0.0,
        act=0.0,
    ),
}

# Special marker for Phase 0
INTAKE_IS_PRE_INVESTIGATION = True  # Phase 0 is consent, not yet investigating


def is_step_allowed(phase: InvestigationPhase, step: OODAStep) -> bool:
    """Check if OODA step is allowed in phase (derived from weights)

    Single source of truth: PHASE_OODA_WEIGHTS
    Binary activation derived: weight > 0.0 means allowed

    Args:
        phase: Investigation phase
        step: OODA step

    Returns:
        True if step is allowed (has non-zero weight)
    """
    profile = PHASE_OODA_WEIGHTS[phase]
    return profile.is_step_allowed(step)


# =============================================================================
# Core Investigation State Models
# =============================================================================


class ProblemConfirmation(BaseModel):
    """Phase 0 problem triage structure (informal, pre-investigation)

    Created in Consultant Mode before Lead Investigator activation.
    Distinct from AnomalyFrame (Phase 1 formal definition).

    Workflow:
    1. Agent synthesizes from user conversation
    2. Creates ProblemConfirmation
    3. User consents â†’ Mode switch to Lead Investigator
    4. Phase 1 creates AnomalyFrame (formal)
    """
    problem_statement: str = Field(..., description="User's problem description")
    affected_components: List[str] = Field(default_factory=list, description="Approximate components")
    severity: str = Field(..., description="Initial severity assessment")
    impact: str = Field(..., description="Who/what is affected")
    investigation_approach: str = Field(..., description="Proposed strategy")
    estimated_evidence_needed: List[str] = Field(
        default_factory=list,
        description="Expected evidence categories"
    )
    urgency_signals: Optional[Dict[str, Optional[str]]] = Field(
        default=None,
        description="Contextual hints from Phase 0 signal detection (urgency_hint, temporal_hint, scope_hint, source)"
    )


class AnomalyFrame(BaseModel):
    """Formal problem definition created in Phase 1 (Blast Radius)

    Created via OODA Orient step after evidence gathering.
    More structured than ProblemConfirmation, revisable as investigation progresses.
    """
    statement: str = Field(..., description="Formal problem statement")
    affected_components: List[str] = Field(default_factory=list)
    affected_scope: str = Field(..., description="Impact radius")
    started_at: datetime = Field(..., description="When issue started")
    severity: str = Field(..., description="low, medium, high, critical")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence in framing")

    # Revision tracking
    revision_count: int = Field(default=0, description="Number of times revised")
    framed_at_turn: int = Field(..., description="Turn when initially framed")
    revised_at_turns: List[int] = Field(default_factory=list, description="Turns when revised")


class TemporalFrame(BaseModel):
    """Timeline context established in Phase 2 (Timeline)

    Captures temporal understanding of when issue started, recent changes,
    and event correlation. Created via OODA Orient step after timeline evidence gathering.

    Design Reference: docs/architecture/investigation-phases-and-ooda-integration.md
    """
    # First occurrence
    first_noticed_at: Optional[datetime] = Field(
        None,
        description="When symptoms were first noticed by user"
    )
    actually_started_at: Optional[datetime] = Field(
        None,
        description="When issue actually started (may differ from first_noticed)"
    )
    temporal_pattern: str = Field(
        ...,
        description="sudden, gradual, intermittent, or unknown"
    )

    # Recent changes
    recent_changes: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Deployments, config changes, traffic patterns within relevant window"
    )
    change_correlation: Optional[str] = Field(
        None,
        description="How changes correlate with symptoms (strong, weak, none, unknown)"
    )

    # Timeline quality
    confidence: float = Field(
        default=0.5,
        ge=0.0,
        le=1.0,
        description="Confidence in timeline accuracy"
    )
    completeness: str = Field(
        ...,
        description="complete, partial, minimal - indicates timeline data quality"
    )
    established_at_turn: int = Field(..., description="Turn when timeline established")

    # Revision tracking (timeline may be corrected in Phase 4)
    revision_count: int = Field(default=0)
    revised_at_turns: List[int] = Field(default_factory=list)


class Hypothesis(BaseModel):
    """Root cause hypothesis with continuous generation support

    Supports both opportunistic (early intuition) and systematic (Phase 3) generation.

    Lifecycle:
    - CAPTURED: Opportunistic hypothesis from Phases 0-2 (low confidence=0.3)
    - ACTIVE: Promoted to testing (systematic or well-supported opportunistic)
    - VALIDATED/REFUTED: Test results
    - RETIRED: Low confidence or anchoring
    - SUPERSEDED: Better hypothesis found
    """

    hypothesis_id: str = Field(default_factory=lambda: str(uuid4()))
    statement: str = Field(..., description="Hypothesis statement")
    category: str = Field(..., description="infrastructure, code, config, etc.")

    # Generation metadata (Proposal #2: Continuous Hypothesis Generation)
    generation_mode: HypothesisGenerationMode = Field(
        default=HypothesisGenerationMode.SYSTEMATIC,
        description="How this hypothesis was generated"
    )
    captured_in_phase: InvestigationPhase = Field(
        ...,
        description="Phase when hypothesis was first captured/generated"
    )
    captured_at_turn: int = Field(..., description="Turn when captured/generated")

    # Lifecycle tracking
    status: HypothesisStatus = Field(default=HypothesisStatus.ACTIVE)
    promoted_to_active_at_turn: Optional[int] = Field(
        default=None,
        description="Turn when promoted from CAPTURED to ACTIVE"
    )
    retired_at_turn: Optional[int] = Field(default=None)
    retirement_reason: Optional[str] = None

    # Triggering context (for opportunistic hypotheses)
    triggering_observation: Optional[str] = Field(
        default=None,
        description="What sparked this hypothesis (first ~200 chars of context)"
    )

    # Confidence management
    likelihood: float = Field(..., ge=0.0, le=1.0, description="Current confidence")
    initial_likelihood: float = Field(..., ge=0.0, le=1.0, description="Original confidence")
    confidence_trajectory: List[Tuple[int, float]] = Field(
        default_factory=list,
        description="(turn, confidence) history"
    )

    # Legacy fields (backward compatibility)
    created_at_turn: int = Field(..., description="Legacy: same as captured_at_turn")
    last_updated_turn: int = Field(..., description="Last modification turn")

    # Evidence linkage
    supporting_evidence: List[str] = Field(default_factory=list, description="Evidence IDs")
    refuting_evidence: List[str] = Field(
        default_factory=list,
        description="Evidence IDs that contradict this hypothesis"
    )

    # Testing metadata
    test_plan: Optional[str] = Field(default=None, description="How to test this hypothesis")
    test_results: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Test execution results"
    )

    # Anchoring prevention
    iterations_without_progress: int = Field(default=0)
    last_progress_at_turn: Optional[int] = None

    def apply_confidence_decay(self, current_turn: int) -> float:
        """Decay confidence if no progress made

        Args:
            current_turn: Current conversation turn

        Returns:
            Updated likelihood after decay
        """
        turns_since_progress = current_turn - (self.last_progress_at_turn or self.created_at_turn)

        if turns_since_progress >= 2:
            decay_factor = 0.85 ** self.iterations_without_progress
            self.likelihood = self.initial_likelihood * decay_factor

            if self.likelihood < 0.3:
                self.status = HypothesisStatus.RETIRED
                self.retirement_reason = "Confidence decayed below threshold"

        return self.likelihood


class HypothesisTest(BaseModel):
    """Record of hypothesis testing during Phase 4 (Validation)"""

    test_id: str = Field(default_factory=lambda: str(uuid4()))
    hypothesis_id: str = Field(..., description="Hypothesis being tested")
    test_description: str = Field(..., description="What was tested")
    evidence_required: List[str] = Field(default_factory=list, description="Evidence request IDs")
    evidence_obtained: List[str] = Field(default_factory=list, description="Evidence provided IDs")

    result: str = Field(..., description="supports, refutes, inconclusive")
    confidence_change: float = Field(..., description="Change in hypothesis likelihood")

    executed_at_turn: int = Field(...)
    ooda_iteration: int = Field(..., description="Which OODA iteration")


class OODAIteration(BaseModel):
    """One complete OODA cycle (Observeâ†’Orientâ†’Decideâ†’Act)"""

    iteration_id: str = Field(default_factory=lambda: str(uuid4()))
    iteration_number: int = Field(..., description="Iteration count in current phase")
    phase: InvestigationPhase = Field(..., description="Which investigation phase")

    # Timing
    started_at_turn: int = Field(...)
    completed_at_turn: Optional[int] = None
    duration_turns: int = Field(default=0)

    # Steps executed
    steps_completed: List[OODAStep] = Field(default_factory=list)
    steps_skipped: List[OODAStep] = Field(default_factory=list)

    # State changes during this iteration
    anomaly_refined: bool = Field(default=False, description="AnomalyFrame updated")
    new_evidence_collected: int = Field(default=0)
    hypotheses_generated: int = Field(default=0)
    hypotheses_tested: int = Field(default=0)
    hypotheses_retired: int = Field(default=0)

    # Progress tracking
    confidence_delta: float = Field(default=0.0, description="Change in max hypothesis confidence")
    new_insights: List[str] = Field(default_factory=list)
    made_progress: bool = Field(default=False)
    # Note: stall_reason removed in v3.0 (replaced with progress_metrics)


class PhaseTransition(BaseModel):
    """Record of phase advancement"""

    from_phase: InvestigationPhase
    to_phase: InvestigationPhase
    transition_reason: str = Field(..., description="Why phase advanced")
    occurred_at_turn: int = Field(...)
    completion_criteria_met: List[str] = Field(default_factory=list)
    skipped_phases: List[InvestigationPhase] = Field(
        default_factory=list,
        description="Phases skipped (e.g., critical incident)"
    )


# =============================================================================
# Working Conclusion and Progress Tracking Models (v3.0)
# =============================================================================


class WorkingConclusion(BaseModel):
    """Agent's current best understanding of the problem (v3.0)

    Replaces stall detection system. Agent ALWAYS maintains working conclusion
    with varying confidence levels, continuously updated every turn based on evidence.

    Design Reference:
    - docs/architecture/investigation-phases-and-ooda-integration.md (v3.0)
    """
    # Current understanding
    statement: str = Field(..., description="Current best understanding of root cause")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence level (0.0-1.0)")
    confidence_level: ConfidenceLevel = Field(..., description="Human-readable confidence")

    # Evidence basis
    supporting_evidence_count: int = Field(default=0)
    total_evidence_count: int = Field(default=0)
    evidence_completeness: float = Field(default=0.0, ge=0.0, le=1.0, description="Per-hypothesis completeness")

    # Transparency (what agent communicates to user)
    caveats: List[str] = Field(
        default_factory=list,
        description="Limitations and uncertainties to communicate"
    )
    alternative_explanations: List[str] = Field(
        default_factory=list,
        description="Other hypotheses under consideration"
    )

    # Action guidance
    can_proceed_with_solution: bool = Field(default=False, description="Confidence â‰¥ 70%")
    next_evidence_needed: List[str] = Field(default_factory=list)

    # Metadata
    last_updated_turn: int = Field(...)
    last_confidence_change_turn: int = Field(...)
    generated_at_turn: int = Field(..., description="When this conclusion was generated")

    @classmethod
    def from_confidence(cls, confidence: float, **kwargs) -> "WorkingConclusion":
        """Create WorkingConclusion with auto-detected confidence level"""
        if confidence >= 0.90:
            level = ConfidenceLevel.VERIFIED
        elif confidence >= 0.70:
            level = ConfidenceLevel.CONFIDENT
        elif confidence >= 0.50:
            level = ConfidenceLevel.PROBABLE
        else:
            level = ConfidenceLevel.SPECULATION

        return cls(
            confidence=confidence,
            confidence_level=level,
            can_proceed_with_solution=(confidence >= 0.70),
            **kwargs
        )


class ProgressMetrics(BaseModel):
    """Investigation progress tracking (v3.0)

    Replaces binary "stalled/not-stalled" with continuous progress measurement.
    Tracks evidence collection, investigation momentum, and hypothesis progress.
    """
    # Evidence collection progress
    evidence_completeness: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="Percentage of required evidence collected across all hypotheses"
    )
    evidence_blocked_count: int = Field(default=0, description="Critical evidence requests blocked")
    evidence_pending_count: int = Field(default=0, description="Evidence awaiting user response")

    # Investigation momentum
    investigation_momentum: InvestigationMomentum = Field(default=InvestigationMomentum.MODERATE)
    turns_since_last_progress: int = Field(default=0, description="Progress = evidence added OR confidence changed")

    # Hypothesis progress
    active_hypotheses_count: int = Field(default=0)
    hypotheses_with_sufficient_evidence: int = Field(default=0, description="Evidence completeness â‰¥ 70%")
    highest_hypothesis_confidence: float = Field(default=0.0, ge=0.0, le=1.0)

    # Next steps
    next_steps: List[str] = Field(default_factory=list, description="What agent plans to do next")
    blocked_reasons: List[str] = Field(
        default_factory=list,
        description="If momentum low, why? (transparent communication)"
    )

    def should_suggest_closure(self, state: "InvestigationState") -> bool:
        """Determine if agent should suggest closing investigation

        Replaces stall detection. Suggests closure based on progress metrics.

        Args:
            state: Current investigation state

        Returns:
            True if should suggest closure (confidence low, evidence blocked, no progress)
        """
        working_conclusion = getattr(state.lifecycle, 'working_conclusion', None)
        if not working_conclusion:
            return False

        return (
            self.turns_since_last_progress >= 3
            and working_conclusion.confidence < 0.5
            and self.investigation_momentum == InvestigationMomentum.BLOCKED
            and self.evidence_blocked_count >= 2
        )


class EscalationState(BaseModel):
    """Escalation and degraded mode tracking (v3.0)

    Tracks when investigation encounters limitations and enters degraded mode
    or requires escalation. Replaces mode switching (Consultant â†” Lead Investigator).
    """
    # Escalation tracking
    escalation_suggested: bool = Field(default=False, description="Agent suggested escalation")
    escalation_suggested_at_turn: Optional[int] = None
    escalation_reason: Optional[str] = None
    user_decision: Optional[str] = Field(
        default=None,
        description="accept_escalation, continue_degraded, ask_questions"
    )

    # Degraded mode (v3.0 NEW)
    operating_in_degraded_mode: bool = Field(default=False)
    degraded_mode_type: Optional[DegradedModeType] = None
    degraded_mode_explanation: Optional[str] = None
    entered_degraded_mode_at_turn: Optional[int] = None

    # Re-escalation prompting
    last_escalation_prompt_turn: int = Field(default=0, description="Last time suggested escalation")

    def get_confidence_cap(self) -> Optional[float]:
        """Get confidence cap based on degraded mode type

        Returns:
            Confidence cap (0.0-0.5) or None if not in degraded mode
        """
        if not self.operating_in_degraded_mode or not self.degraded_mode_type:
            return None
        return get_confidence_cap(self.degraded_mode_type)


# =============================================================================
# Memory Management Models
# =============================================================================


class MemorySnapshot(BaseModel):
    """Compressed memory snapshot for warm/cold tiers"""

    snapshot_id: str = Field(default_factory=lambda: str(uuid4()))
    iteration_range: Tuple[int, int] = Field(..., description="(start, end) iteration numbers")
    summary: str = Field(..., description="LLM-generated summary")
    key_facts: List[str] = Field(default_factory=list)
    confidence_changes: Dict[str, float] = Field(default_factory=dict)
    evidence_collected: List[str] = Field(default_factory=list, description="Evidence IDs")
    decisions_made: List[str] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class HierarchicalMemory(BaseModel):
    """Token-optimized memory system with hot/warm/cold tiers

    Token Budget: ~1,600 tokens total (vs 4,500+ unmanaged)
    - Hot Memory: ~500 tokens (last 2 iterations, full fidelity)
    - Warm Memory: ~300 tokens (iterations 3-5, summarized)
    - Cold Memory: ~100 tokens (older, key facts only)
    - Persistent Insights: ~100 tokens (always accessible)

    Compression: Triggered every 3 turns (64% reduction)
    """

    # Hot memory: Full detail, last 2 iterations
    hot_memory: List[OODAIteration] = Field(
        default_factory=list,
        description="Last 2 OODA iterations (full fidelity)"
    )

    # Warm memory: Summarized, iterations 3-5
    warm_snapshots: List[MemorySnapshot] = Field(
        default_factory=list,
        description="Iterations 3-5 (summarized, max 3)"
    )

    # Cold memory: Key facts, older iterations
    cold_snapshots: List[MemorySnapshot] = Field(
        default_factory=list,
        description="Older iterations (key facts only, max 5)"
    )

    # Persistent: Always accessible insights
    persistent_insights: List[str] = Field(
        default_factory=list,
        description="Key learnings maintained across all turns"
    )

    last_compression_turn: int = Field(default=0)

    def should_compress(self, current_turn: int) -> bool:
        """Check if compression should be triggered

        Args:
            current_turn: Current conversation turn

        Returns:
            True if compression needed (every 3 turns)
        """
        return current_turn % 3 == 0 and current_turn > self.last_compression_turn


# =============================================================================
# Investigation State Layers
# =============================================================================


class InvestigationMetadata(BaseModel):
    """Metadata Layer - Identity and timestamps"""

    investigation_id: str = Field(default_factory=lambda: str(uuid4()))
    session_id: str = Field(..., description="Session this investigation belongs to")
    user_id: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    last_updated: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    current_turn: int = Field(default=1, description="Current conversation turn")
    engagement_mode: EngagementMode = Field(default=EngagementMode.CONSULTANT)


class InvestigationLifecycle(BaseModel):
    """Lifecycle Layer - Phase progression and status"""

    current_phase: InvestigationPhase = Field(default=InvestigationPhase.INTAKE)
    phase_name: str = Field(default="intake", description="intake, blast_radius, etc.")
    entry_phase: InvestigationPhase = Field(
        default=InvestigationPhase.INTAKE,
        description="Where investigation started"
    )

    # Case status (from case-lifecycle-management.md)
    case_status: str = Field(default="consulting", description="Case lifecycle status (consulting|investigating|resolved|closed)")
    urgency_level: str = Field(default="medium", description="low, medium, high, critical")
    investigation_strategy: Optional[InvestigationStrategy] = None

    # Phase history
    phase_history: List[PhaseTransition] = Field(default_factory=list)
    turns_in_current_phase: int = Field(default=0)
    phase_complete: bool = Field(default=False)

    # Loop-back tracking (Proposal #6)
    loop_back_count: int = Field(
        default=0,
        description="Number of times investigation has looped back to earlier phases"
    )
    loop_back_history: List[dict] = Field(
        default_factory=list,
        description="History of loop-back events with reasons"
    )

    # Document phase tracking
    artifacts_offered: bool = Field(
        default=False,
        description="Whether documentation artifacts have been offered to user"
    )

    # Working conclusion and progress tracking (v3.0 NEW)
    working_conclusion: Optional[WorkingConclusion] = Field(
        default=None,
        description="Agent's current best understanding (updated every turn)"
    )
    progress_metrics: ProgressMetrics = Field(
        default_factory=ProgressMetrics,
        description="Investigation progress tracking (replaces stall detection)"
    )

    # Escalation and degraded mode (v3.0 NEW)
    escalation_state: EscalationState = Field(
        default_factory=EscalationState,
        description="Escalation and degraded mode tracking"
    )

    # Phase entry history (for entry mode detection in Phase 5/6)
    phase_entry_history: List[InvestigationPhase] = Field(
        default_factory=list,
        description="Track which phase was entered from (for Phase 5/6 mode detection)"
    )

    # Workflow progression tracking (v3.0 NEW)
    # Agent-initiated confirmations for progressing through investigation workflow
    pending_workflow_progression: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Pending workflow progression awaiting user confirmation"
    )
    workflow_progression_attempts: int = Field(
        default=0,
        description="Number of confirmation attempts for current workflow progression"
    )
    last_workflow_progression_prompt: Optional[str] = Field(
        default=None,
        description="Last workflow progression suggestion timestamp"
    )

    # Solution tracking (v3.0 NEW - for workflow progression detection)
    solution_verified: bool = Field(
        default=False,
        description="Whether solution has been verified as working"
    )
    solution_summary: Optional[str] = Field(
        default=None,
        description="Summary of solution that was applied"
    )
    verification_details: Optional[str] = Field(
        default=None,
        description="Details of how solution was verified"
    )
    completeness_level: Optional[str] = Field(
        default=None,
        description="Investigation completeness: FULL, HIGH, PARTIAL, or MINIMAL"
    )


class OODAEngineState(BaseModel):
    """OODA Engine Layer - Tactical execution state"""

    ooda_active: bool = Field(default=False, description="OODA framework active (Phases 1-6)")
    current_step: Optional[OODAStep] = None
    current_iteration: int = Field(default=0, description="OODA iteration count in current phase")

    # Core investigation objects (per design: investigation-phases-and-ooda-integration.md)
    anomaly_frame: Optional[AnomalyFrame] = None  # Created in Phase 1 (Blast Radius)
    temporal_frame: Optional[TemporalFrame] = None  # Created in Phase 2 (Timeline)
    hypotheses: List[Hypothesis] = Field(default_factory=list)  # Generated in Phase 3, tested in Phase 4
    tests_performed: List[HypothesisTest] = Field(default_factory=list)

    # Iteration tracking
    iterations: List[OODAIteration] = Field(default_factory=list)

    # Anchoring detection
    anchoring_detected: bool = Field(default=False)
    forced_alternatives_at_turn: List[int] = Field(default_factory=list)
    confidence_trajectory: List[float] = Field(
        default_factory=list,
        description="Max hypothesis confidence per turn"
    )


class EvidenceLayer(BaseModel):
    """Evidence Layer - Evidence collection and tracking

    Note: Evidence schemas defined in evidence.py
    This layer references those models
    """

    evidence_requests: List[str] = Field(
        default_factory=list,
        description="Evidence request IDs (see evidence.py)"
    )
    evidence_provided: List[str] = Field(
        default_factory=list,
        description="Evidence provided IDs (see evidence.py)"
    )
    evidence_coverage_score: float = Field(default=0.0, ge=0.0, le=1.0)
    critical_evidence_blocked: List[str] = Field(
        default_factory=list,
        description="Critical evidence requests blocked by user"
    )


class MemoryLayer(BaseModel):
    """Memory Layer - Hierarchical memory management"""

    hierarchical_memory: HierarchicalMemory = Field(default_factory=HierarchicalMemory)
    token_budget_used: int = Field(default=0, description="Approximate tokens in state")
    compression_count: int = Field(default=0, description="Times compression triggered")


# =============================================================================
# Root Investigation State
# =============================================================================


class InvestigationState(BaseModel):
    """Root investigation state with 5 hierarchical layers

    Design: investigation-phases-and-ooda-integration.md

    Layers:
    1. Metadata Layer - Identity and timestamps
    2. Lifecycle Layer - Phase progression
    3. OODA Engine Layer - Tactical execution
    4. Evidence Layer - Evidence tracking
    5. Memory Layer - Token-optimized memory

    Token Budget: ~1,600 tokens (vs 4,500+ unmanaged, 64% reduction)
    """

    # Layer 1: Metadata
    metadata: InvestigationMetadata = Field(default_factory=InvestigationMetadata)

    # Layer 2: Lifecycle
    lifecycle: InvestigationLifecycle = Field(default_factory=InvestigationLifecycle)

    # Layer 3: OODA Engine
    ooda_engine: OODAEngineState = Field(default_factory=OODAEngineState)

    # Layer 4: Evidence (references evidence.py models)
    evidence: EvidenceLayer = Field(default_factory=EvidenceLayer)

    # Layer 5: Memory
    memory: MemoryLayer = Field(default_factory=MemoryLayer)

    # Problem confirmation (Phase 0)
    problem_confirmation: Optional[ProblemConfirmation] = None
